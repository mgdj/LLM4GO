Command executed successfully. Output saved to ./function-summary.txt
YieldToken:
__ERC20Permit_init:
__ERC20Permit_init_unchained:
permit:
nonces:
DOMAIN_SEPARATOR:
_getNoncesStorage:
__Nonces_init:
__Nonces_init_unchained:
nonces:
_useNonce:
_useCheckedNonce:
_checkInitializing:
_disableInitializers:
_getInitializedVersion:
_isInitializing:
_getInitializableStorage:
_getEIP712Storage:
__EIP712_init:
__EIP712_init_unchained:
_domainSeparatorV4:
_buildDomainSeparator:
_hashTypedDataV4:
eip712Domain:
_EIP712Name:
_EIP712Version:
_EIP712NameHash:
_EIP712VersionHash:
eip712Domain:
permit:
nonces:
DOMAIN_SEPARATOR:
_getERC20Storage:
__ERC20_init:
__ERC20_init_unchained:
name:
symbol:
decimals:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals()
        public
        view
        virtual
        override(IYieldToken, ERC20Upgradeable)
        returns (uint8)
    {
        return IERC20Metadata(pt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-decimals.txt
totalSupply:
balanceOf:

there may be a problem : Do not declare local variables used only once in balanceOf
['2.11', '4.1', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:$
function state variables read:
function state variables written:
    function balanceOf(
        address account
    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {
        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-balanceOf.txt
transfer:

there may be a problem : Do not declare local variables used only once in transfer
['2.11', '4.1', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:owner
function state variables read:
function state variables written:
    function transfer(
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);
        return super.transfer(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transfer.txt
allowance:
approve:
transferFrom:

there may be a problem : Do not declare local variables used only once in transferFrom
['2.11', '4.1', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:spender
function state variables read:
function state variables written:
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(from, to);
        return super.transferFrom(from, to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transferFrom.txt
_transfer:
_update:
_mint:
_burn:
_approve:
_approve:
_spendAllowance:
name:
symbol:
decimals:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals()
        public
        view
        virtual
        override(IYieldToken, ERC20Upgradeable)
        returns (uint8)
    {
        return IERC20Metadata(pt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-decimals.txt
totalSupply:
balanceOf:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function balanceOf(
        address account
    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {
        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-balanceOf.txt
transfer:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function transfer(
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);
        return super.transfer(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transfer.txt
allowance:
approve:
transferFrom:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(from, to);
        return super.transferFrom(from, to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transferFrom.txt
__Context_init:
__Context_init_unchained:
_msgSender:
_msgData:
_contextSuffixLength:
initialize:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function initialize

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function initialize(
        string calldata _name,
        string calldata _symbol,
        address _pt
    ) external initializer {
        __ERC20_init(_name, _symbol);
        __ERC20Permit_init(_name);
        pt = _pt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-initialize.txt
decimals:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals()
        public
        view
        virtual
        override(IYieldToken, ERC20Upgradeable)
        returns (uint8)
    {
        return IERC20Metadata(pt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-decimals.txt
getPT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getPT() public view virtual override returns (address) {
        return pt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-getPT.txt
transfer:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function transfer(
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);
        return super.transfer(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transfer.txt
transferFrom:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(from, to);
        return super.transferFrom(from, to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transferFrom.txt
burnWithoutUpdate:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function burnWithoutUpdate(address from, uint256 amount) external override {
        if (msg.sender != pt) {
            revert CallerIsNotPtContract();
        }
        _burn(from, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-burnWithoutUpdate.txt
mint:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function mint(address to, uint256 amount) external override {
        if (msg.sender != pt) {
            revert CallerIsNotPtContract();
        }
        _mint(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-mint.txt
burn:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function burn(uint256 amount) public override {
        IPrincipalToken(pt).updateYield(msg.sender);
        _burn(msg.sender, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-burn.txt
balanceOf:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function balanceOf(
        address account
    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {
        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-balanceOf.txt
actualBalanceOf:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function actualBalanceOf(address account) public view override returns (uint256) {
        return super.balanceOf(account);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-actualBalanceOf.txt
constructor:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    constructor() {
        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-constructor.txt
initialize:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function initialize

there may be a problem : check before updating state variable with same value in initialize
['2.11', '1.1', '4.1', '2.4', '3.6', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:pt
    function initialize(
        string calldata _name,
        string calldata _symbol,
        address _pt
    ) external initializer {
        __ERC20_init(_name, _symbol);
        __ERC20Permit_init(_name);
        pt = _pt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-initialize.txt
burnWithoutUpdate:
pt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function burnWithoutUpdate(address from, uint256 amount) external override {
        if (msg.sender != pt) {
            revert CallerIsNotPtContract();
        }
        _burn(from, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-burnWithoutUpdate.txt
mint:
pt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function mint(address to, uint256 amount) external override {
        if (msg.sender != pt) {
            revert CallerIsNotPtContract();
        }
        _mint(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-mint.txt
burn:
pt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function burn(uint256 amount) public override {
        IPrincipalToken(pt).updateYield(msg.sender);
        _burn(msg.sender, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-burn.txt
transfer:
pt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function transfer(
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);
        return super.transfer(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transfer.txt
transferFrom:
pt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(from, to);
        return super.transferFrom(from, to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transferFrom.txt
decimals:
pt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function decimals()
        public
        view
        virtual
        override(IYieldToken, ERC20Upgradeable)
        returns (uint8)
    {
        return IERC20Metadata(pt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-decimals.txt
getPT:
pt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function getPT() public view virtual override returns (address) {
        return pt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-getPT.txt
balanceOf:
pt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function balanceOf(
        address account
    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {
        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-balanceOf.txt
actualBalanceOf:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function actualBalanceOf(address account) public view override returns (uint256) {
        return super.balanceOf(account);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-actualBalanceOf.txt
there may be a problem : Pack the variables into fewer storage slots by re-ordering the variables or reducing their sizes in YieldToken
there may be a problem : Using bools for storage incurs overhead in YieldToken
['3.4', '3.7']
hint message:
1.Pack the variables into fewer storage slots by re-ordering the variables or reducing their sizes
You should first determine whether there is a situation in which these variables can reduce size, such as some variables about time, and then after reducing size of the variable, you need to determine whether you can adjust the order of the variables to make storage more space-saving. And of course you also have to think about what's going on inside the struct.
    exmaple:
-    uint256 public LastDistribution;
    uint256 public MinDistributionPeriod;
+    uint48 public LastDistribution;
    bool public LockedForDistribution;
    LastDistribution can be reduced to uint48 since it holds block number so uint48 is more than sufficient to hold any realistic block number of any blockchain.
    2.Using bools for storage incurs overhead,instead use uint256
You first need to find those state variables that refer to bool. To mitigate these gas costs, you can utilize uint256 values uint256(1) and uint256(2) to represent true and false respectively including the variables in mapping.
    
content:
solidity version :0.8.20
variable written only construct:[]
contract YieldToken is IYieldToken, ERC20PermitUpgradeable {
    using Math for uint256;
    address private pt;
    constructor() {
        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.
    }

path:
/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken.txt
PrincipalToken:
initialize:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function initialize

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function initialize(
        address _ibt,
        uint256 _duration,
        address _initialAuthority
    ) external initializer {
        if (_ibt == address(0) || _initialAuthority == address(0)) {
            revert AddressError();
        }
        if (IERC4626(_ibt).totalAssets() == 0) {
            revert RateError();
        }
        _asset = IERC4626(_ibt).asset();
        duration = _duration;
        expiry = _duration + block.timestamp;
        string memory _ibtSymbol = IERC4626(_ibt).symbol();
        string memory name = NamingUtil.genPTName(_ibtSymbol, expiry);
        __ERC20_init(name, NamingUtil.genPTSymbol(_ibtSymbol, expiry));
        __ERC20Permit_init(name);
        __Pausable_init();
        __ReentrancyGuard_init();
        __AccessManaged_init(_initialAuthority);
        _ibtDecimals = IERC4626(_ibt).decimals();
        _assetDecimals = PrincipalTokenUtil._tryGetTokenDecimals(_asset);
        if (
            _assetDecimals < MIN_DECIMALS ||
            _assetDecimals > _ibtDecimals ||
            _ibtDecimals > MAX_DECIMALS
        ) {
            revert InvalidDecimals();
        }
        ibt = _ibt;
        ibtUnit = 10 ** _ibtDecimals;
        ibtRate = IERC4626(ibt).previewRedeem(ibtUnit).toRay(_assetDecimals);
        ptRate = RayMath.RAY_UNIT;
        yt = _deployYT(
            NamingUtil.genYTName(_ibtSymbol, expiry),
            NamingUtil.genYTSymbol(_ibtSymbol, expiry)
        );
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-initialize.txt
pause:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function pause

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function pause() external override restricted {
        _pause();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-pause.txt
unPause:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function unPause

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function unPause() external override restricted {
        _unpause();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-unPause.txt
deposit:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
deposit:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
deposit:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
depositIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
depositIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
depositIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
redeem:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 assets) {
        _beforeRedeem(shares, owner);
        assets = IERC4626(ibt).redeem(_convertSharesToIBTs(shares, false), receiver, address(this));
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeem.txt
redeem:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 assets) {
        _beforeRedeem(shares, owner);
        assets = IERC4626(ibt).redeem(_convertSharesToIBTs(shares, false), receiver, address(this));
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeem.txt
redeemForIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeemForIBT(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 ibts) {
        _beforeRedeem(shares, owner);
        ibts = _convertSharesToIBTs(shares, false);
        IERC20(ibt).safeTransfer(receiver, ibts);
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeemForIBT.txt
redeemForIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeemForIBT(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 ibts) {
        _beforeRedeem(shares, owner);
        ibts = _convertSharesToIBTs(shares, false);
        IERC20(ibt).safeTransfer(receiver, ibts);
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeemForIBT.txt
withdraw:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(assets, owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 ibts = IERC4626(ibt).withdraw(assets, receiver, address(this));
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdraw.txt
withdraw:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(assets, owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 ibts = IERC4626(ibt).withdraw(assets, receiver, address(this));
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdraw.txt
withdrawIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdrawIBT(
        uint256 ibts,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(IERC4626(ibt).previewRedeem(ibts), owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
        // send IBTs from this contract to receiver
        IERC20(ibt).safeTransfer(receiver, ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdrawIBT.txt
withdrawIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdrawIBT(
        uint256 ibts,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(IERC4626(ibt).previewRedeem(ibts), owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
        // send IBTs from this contract to receiver
        IERC20(ibt).safeTransfer(receiver, ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdrawIBT.txt
updateYield:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function updateYield(address _user) public override returns (uint256 updatedUserYieldInIBT) {
        (uint256 _ptRate, uint256 _ibtRate) = _updatePTandIBTRates();

        uint256 _oldIBTRateUser = ibtRateOfUser[_user];
        if (_oldIBTRateUser != _ibtRate) {
            ibtRateOfUser[_user] = _ibtRate;
        }
        uint256 _oldPTRateUser = ptRateOfUser[_user];
        if (_oldPTRateUser != _ptRate) {
            ptRateOfUser[_user] = _ptRate;
        }

        // Check for skipping yield update when the user deposits for the first time or rates decreased to 0.
        if (_oldIBTRateUser != 0) {
            updatedUserYieldInIBT = PrincipalTokenUtil._computeYield(
                _user,
                yieldOfUserInIBT[_user],
                _oldIBTRateUser,
                _ibtRate,
                _oldPTRateUser,
                _ptRate,
                yt
            );
            yieldOfUserInIBT[_user] = updatedUserYieldInIBT;
            emit YieldUpdated(_user, updatedUserYieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-updateYield.txt
claimYield:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function claimYield(address _receiver) public override returns (uint256 yieldInAsset) {
        uint256 yieldInIBT = _claimYield();
        if (yieldInIBT != 0) {
            yieldInAsset = IERC4626(ibt).redeem(yieldInIBT, _receiver, address(this));
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimYield.txt
claimYieldInIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function claimYieldInIBT(address _receiver) public override returns (uint256 yieldInIBT) {
        yieldInIBT = _claimYield();
        if (yieldInIBT != 0) {
            IERC20(ibt).safeTransfer(_receiver, yieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimYieldInIBT.txt
claimFees:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function claimFees() external override returns (uint256 assets) {
        if (msg.sender != IRegistry(registry).getFeeCollector()) {
            revert UnauthorizedCaller();
        }
        uint256 ibts = unclaimedFeesInIBT;
        unclaimedFeesInIBT = 0;
        assets = IERC4626(ibt).redeem(ibts, msg.sender, address(this));
        emit FeeClaimed(msg.sender, ibts, assets);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimFees.txt
beforeYtTransfer:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function beforeYtTransfer(address _from, address _to) external override {
        if (msg.sender != yt) {
            revert UnauthorizedCaller();
        }
        updateYield(_from);
        updateYield(_to);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-beforeYtTransfer.txt
claimRewards:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function claimRewards

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function claimRewards(bytes memory _data) external restricted {
        if (rewardsProxy == address(0)) {
            revert NoRewardsProxySet();
        }
        _data = abi.encodeWithSelector(IRewardsProxy(rewardsProxy).claimRewards.selector, _data);
        (bool success, ) = rewardsProxy.delegatecall(_data);
        if (!success) {
            revert ClaimRewardsFailed();
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimRewards.txt
storeRatesAtExpiry:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function storeRatesAtExpiry

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function storeRatesAtExpiry() public override afterExpiry {
        if (ratesAtExpiryStored) {
            revert RatesAtExpiryAlreadyStored();
        }
        ratesAtExpiryStored = true;
        // PT rate not rounded up here
        (ptRate, ibtRate) = _getCurrentPTandIBTRates(false);
        emit RatesStoredAtExpiry(ibtRate, ptRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-storeRatesAtExpiry.txt
setRewardsProxy:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function setRewardsProxy

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function setRewardsProxy(address _rewardsProxy) external restricted {
        // Note: address zero is allowed in order to disable the claim proxy
        emit RewardsProxyChange(rewardsProxy, _rewardsProxy);
        rewardsProxy = _rewardsProxy;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-setRewardsProxy.txt
previewDeposit:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewDeposit(uint256 assets) public view override returns (uint256) {
        uint256 ibts = IERC4626(ibt).previewDeposit(assets);
        return _previewDepositIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewDeposit.txt
previewDepositIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewDepositIBT(uint256 ibts) external view override returns (uint256) {
        return _previewDepositIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewDepositIBT.txt
maxDeposit:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxDeposit(address) external pure override returns (uint256) {
        return type(uint256).max;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxDeposit.txt
previewWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewWithdraw

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewWithdraw(
        uint256 assets
    ) external view override whenNotPaused returns (uint256) {
        uint256 ibts = IERC4626(ibt).previewWithdraw(assets);
        return previewWithdrawIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewWithdraw.txt
previewWithdrawIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewWithdrawIBT

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewWithdrawIBT(uint256 ibts) public view override whenNotPaused returns (uint256) {
        return _convertIBTsToShares(ibts, true);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewWithdrawIBT.txt
maxWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function maxWithdraw

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxWithdraw(address owner) public view override whenNotPaused returns (uint256) {
        return convertToUnderlying(_maxBurnable(owner));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxWithdraw.txt
maxWithdrawIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function maxWithdrawIBT

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxWithdrawIBT(address owner) public view override whenNotPaused returns (uint256) {
        return _convertSharesToIBTs(_maxBurnable(owner), false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxWithdrawIBT.txt
previewRedeem:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewRedeem(uint256 shares) public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(previewRedeemForIBT(shares));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewRedeem.txt
previewRedeemForIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewRedeemForIBT

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewRedeemForIBT(
        uint256 shares
    ) public view override whenNotPaused returns (uint256) {
        return _convertSharesToIBTs(shares, false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewRedeemForIBT.txt
maxRedeem:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxRedeem(address owner) public view override returns (uint256) {
        return _maxBurnable(owner);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxRedeem.txt
totalAssets:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function totalAssets() public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(IERC4626(ibt).balanceOf(address(this)));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-totalAssets.txt
convertToPrincipal:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function convertToPrincipal(uint256 underlyingAmount) external view override returns (uint256) {
        return _convertIBTsToShares(IERC4626(ibt).previewDeposit(underlyingAmount), false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-convertToPrincipal.txt
convertToUnderlying:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function convertToUnderlying(uint256 principalAmount) public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(_convertSharesToIBTs(principalAmount, false));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-convertToUnderlying.txt
underlying:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function underlying() external view override returns (address) {
        return _asset;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-underlying.txt
maturity:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maturity() external view override returns (uint256) {
        return expiry;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maturity.txt
getDuration:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getDuration() external view override returns (uint256) {
        return duration;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getDuration.txt
getIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getIBT() external view override returns (address) {
        return ibt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBT.txt
getYT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getYT() external view override returns (address) {
        return yt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getYT.txt
getIBTRate:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getIBTRate() external view override returns (uint256) {
        (, uint256 _ibtRate) = _getPTandIBTRates(false);
        return _ibtRate;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBTRate.txt
getPTRate:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getPTRate() external view override returns (uint256) {
        (uint256 _ptRate, ) = _getPTandIBTRates(false);
        return _ptRate;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getPTRate.txt
getIBTUnit:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getIBTUnit() external view override returns (uint256) {
        return ibtUnit;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBTUnit.txt
getUnclaimedFeesInIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getUnclaimedFeesInIBT() external view override returns (uint256) {
        return unclaimedFeesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getUnclaimedFeesInIBT.txt
getTotalFeesInIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getTotalFeesInIBT() external view override returns (uint256) {
        return totalFeesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getTotalFeesInIBT.txt
getTokenizationFee:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getTokenizationFee() public view override returns (uint256) {
        return IRegistry(registry).getTokenizationFee();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getTokenizationFee.txt
getCurrentYieldOfUserInIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getCurrentYieldOfUserInIBT(
        address _user
    ) external view override returns (uint256 _yieldOfUserInIBT) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 _oldIBTRate = ibtRateOfUser[_user];
        uint256 _oldPTRate = ptRateOfUser[_user];
        if (_oldIBTRate != 0) {
            _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
                _user,
                yieldOfUserInIBT[_user],
                _oldIBTRate,
                _ibtRate,
                _oldPTRate,
                _ptRate,
                yt
            );
            _yieldOfUserInIBT -= PrincipalTokenUtil._computeYieldFee(_yieldOfUserInIBT, registry);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getCurrentYieldOfUserInIBT.txt
maxFlashLoan:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxFlashLoan(address _token) public view override returns (uint256) {
        if (_token != ibt) {
            return 0;
        }
        // Entire IBT balance of the contract can be borrowed
        return IERC4626(ibt).balanceOf(address(this));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxFlashLoan.txt
flashFee:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function flashFee(address _token, uint256 _amount) public view override returns (uint256) {
        if (_token != ibt) revert AddressError();
        return PrincipalTokenUtil._computeFlashloanFee(_amount, registry);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-flashFee.txt
flashLoan:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function flashLoan(
        IERC3156FlashBorrower _receiver,
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external override returns (bool) {
        if (_amount > maxFlashLoan(_token)) revert FlashLoanExceedsMaxAmount();

        uint256 fee = flashFee(_token, _amount);
        _updateFees(fee);

        // Initiate the flash loan by lending the requested IBT amount
        IERC20(ibt).safeTransfer(address(_receiver), _amount);

        // Execute the flash loan
        if (_receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) != ON_FLASH_LOAN)
            revert FlashLoanCallbackFailed();

        // Repay the debt + fee
        IERC20(ibt).safeTransferFrom(address(_receiver), address(this), _amount + fee);

        return true;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-flashLoan.txt
name:
symbol:
decimals:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {
        return IERC4626(ibt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-decimals.txt
totalSupply:
balanceOf:
transfer:
allowance:
approve:
transferFrom:
_getPausableStorage:
__Pausable_init:
__Pausable_init_unchained:
paused:
_requireNotPaused:
_requirePaused:
_pause:
_unpause:
__Context_init:
__Context_init_unchained:
_msgSender:
_msgData:
_contextSuffixLength:
_checkInitializing:
_disableInitializers:
_getInitializedVersion:
_isInitializing:
_getInitializableStorage:
_getReentrancyGuardStorage:
__ReentrancyGuard_init:
__ReentrancyGuard_init_unchained:
_nonReentrantBefore:
_nonReentrantAfter:
_reentrancyGuardEntered:
_getAccessManagedStorage:
__AccessManaged_init:
__AccessManaged_init_unchained:
authority:
setAuthority:
isConsumingScheduledOp:
_setAuthority:
_checkCanCall:
authority:
setAuthority:
isConsumingScheduledOp:
__ERC20Permit_init:
__ERC20Permit_init_unchained:
permit:
nonces:
DOMAIN_SEPARATOR:
_getNoncesStorage:
__Nonces_init:
__Nonces_init_unchained:
nonces:
_useNonce:
_useCheckedNonce:
_getEIP712Storage:
__EIP712_init:
__EIP712_init_unchained:
_domainSeparatorV4:
_buildDomainSeparator:
_hashTypedDataV4:
eip712Domain:
_EIP712Name:
_EIP712Version:
_EIP712NameHash:
_EIP712VersionHash:
eip712Domain:
permit:
nonces:
DOMAIN_SEPARATOR:
_getERC20Storage:
__ERC20_init:
__ERC20_init_unchained:
name:
symbol:
decimals:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {
        return IERC4626(ibt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-decimals.txt
totalSupply:
balanceOf:
transfer:
allowance:
approve:
transferFrom:
_transfer:
_update:
_mint:
_burn:
_approve:
_approve:
_spendAllowance:
constructor:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:registry
    constructor(address _registry) {
        if (_registry == address(0)) {
            revert AddressError();
        }
        registry = _registry;
        _disableInitializers(); // using this so that the deployed logic contract cannot later be initialized
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-constructor.txt
initialize:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function initialize
MAX_DECIMALS, MIN_DECIMALS, _asset, _assetDecimals, _ibtDecimals, expiry, ibt, ibtUnit
there may be a problem : Comparison statement order adjustment in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : Comparison statement order adjustment in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : Comparison statement order adjustment in initialize
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in initialize
['2.11', '1.1', '4.1', '2.7', '3.2', '2.4', '3.6', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    5.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    6.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    7.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    8.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:MAX_DECIMALS, MIN_DECIMALS, _asset, _assetDecimals, _ibtDecimals, expiry, ibt, ibtUnit
function state variables written:_asset, _assetDecimals, _ibtDecimals, duration, expiry, ibt, ibtRate, ibtUnit, ptRate, yt
    function initialize(
        address _ibt,
        uint256 _duration,
        address _initialAuthority
    ) external initializer {
        if (_ibt == address(0) || _initialAuthority == address(0)) {
            revert AddressError();
        }
        if (IERC4626(_ibt).totalAssets() == 0) {
            revert RateError();
        }
        _asset = IERC4626(_ibt).asset();
        duration = _duration;
        expiry = _duration + block.timestamp;
        string memory _ibtSymbol = IERC4626(_ibt).symbol();
        string memory name = NamingUtil.genPTName(_ibtSymbol, expiry);
        __ERC20_init(name, NamingUtil.genPTSymbol(_ibtSymbol, expiry));
        __ERC20Permit_init(name);
        __Pausable_init();
        __ReentrancyGuard_init();
        __AccessManaged_init(_initialAuthority);
        _ibtDecimals = IERC4626(_ibt).decimals();
        _assetDecimals = PrincipalTokenUtil._tryGetTokenDecimals(_asset);
        if (
            _assetDecimals < MIN_DECIMALS ||
            _assetDecimals > _ibtDecimals ||
            _ibtDecimals > MAX_DECIMALS
        ) {
            revert InvalidDecimals();
        }
        ibt = _ibt;
        ibtUnit = 10 ** _ibtDecimals;
        ibtRate = IERC4626(ibt).previewRedeem(ibtUnit).toRay(_assetDecimals);
        ptRate = RayMath.RAY_UNIT;
        yt = _deployYT(
            NamingUtil.genYTName(_ibtSymbol, expiry),
            NamingUtil.genYTSymbol(_ibtSymbol, expiry)
        );
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-initialize.txt
pause:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function pause

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function pause() external override restricted {
        _pause();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-pause.txt
unPause:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function unPause

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function unPause() external override restricted {
        _unpause();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-unPause.txt
deposit:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
deposit:
_asset, ibt
there may be a problem : Do not declare local variables used only once in deposit
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in deposit
['2.11', '4.1', '3.5', '3.2', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:ibts
function state variables read:_asset, ibt
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
deposit:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
depositIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
depositIBT:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
depositIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
redeem:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 assets) {
        _beforeRedeem(shares, owner);
        assets = IERC4626(ibt).redeem(_convertSharesToIBTs(shares, false), receiver, address(this));
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeem.txt
redeem:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 assets) {
        _beforeRedeem(shares, owner);
        assets = IERC4626(ibt).redeem(_convertSharesToIBTs(shares, false), receiver, address(this));
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeem.txt
redeemForIBT:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function redeemForIBT(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 ibts) {
        _beforeRedeem(shares, owner);
        ibts = _convertSharesToIBTs(shares, false);
        IERC20(ibt).safeTransfer(receiver, ibts);
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeemForIBT.txt
redeemForIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeemForIBT(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 ibts) {
        _beforeRedeem(shares, owner);
        ibts = _convertSharesToIBTs(shares, false);
        IERC20(ibt).safeTransfer(receiver, ibts);
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeemForIBT.txt
withdraw:
ibt
there may be a problem : Do not declare local variables used only once in withdraw
['2.11', '4.1', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:_ptRate, _ibtRate, ibts
function state variables read:ibt
function state variables written:
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(assets, owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 ibts = IERC4626(ibt).withdraw(assets, receiver, address(this));
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdraw.txt
withdraw:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(assets, owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 ibts = IERC4626(ibt).withdraw(assets, receiver, address(this));
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdraw.txt
withdrawIBT:
ibt
there may be a problem : Do not declare local variables used only once in withdrawIBT
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in withdrawIBT
['2.11', '4.1', '3.5', '3.2', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:_ptRate, _ibtRate
function state variables read:ibt
function state variables written:
    function withdrawIBT(
        uint256 ibts,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(IERC4626(ibt).previewRedeem(ibts), owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
        // send IBTs from this contract to receiver
        IERC20(ibt).safeTransfer(receiver, ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdrawIBT.txt
withdrawIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdrawIBT(
        uint256 ibts,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(IERC4626(ibt).previewRedeem(ibts), owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
        // send IBTs from this contract to receiver
        IERC20(ibt).safeTransfer(receiver, ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdrawIBT.txt
claimFees:
ibt, registry, unclaimedFeesInIBT
there may be a problem : check before updating state variable with same value in claimFees
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in claimFees
['2.11', '4.1', '3.2', '2.4', '3.6', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:ibt, registry, unclaimedFeesInIBT
function state variables written:unclaimedFeesInIBT
    function claimFees() external override returns (uint256 assets) {
        if (msg.sender != IRegistry(registry).getFeeCollector()) {
            revert UnauthorizedCaller();
        }
        uint256 ibts = unclaimedFeesInIBT;
        unclaimedFeesInIBT = 0;
        assets = IERC4626(ibt).redeem(ibts, msg.sender, address(this));
        emit FeeClaimed(msg.sender, ibts, assets);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimFees.txt
updateYield:
ibtRateOfUser, ptRateOfUser, yieldOfUserInIBT, yt
there may be a problem : Comparison statement order adjustment in updateYield
there may be a problem : check before updating state variable with same value in updateYield
there may be a problem : check before updating state variable with same value in updateYield
there may be a problem : check before updating state variable with same value in updateYield
there may be a problem : Comparison statement order adjustment in updateYield
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in updateYield
['2.11', '4.1', '2.7', '3.2', '2.4', '3.6', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    7.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:ibtRateOfUser, ptRateOfUser, yieldOfUserInIBT, yt
function state variables written:ibtRateOfUser, ptRateOfUser, yieldOfUserInIBT
    function updateYield(address _user) public override returns (uint256 updatedUserYieldInIBT) {
        (uint256 _ptRate, uint256 _ibtRate) = _updatePTandIBTRates();

        uint256 _oldIBTRateUser = ibtRateOfUser[_user];
        if (_oldIBTRateUser != _ibtRate) {
            ibtRateOfUser[_user] = _ibtRate;
        }
        uint256 _oldPTRateUser = ptRateOfUser[_user];
        if (_oldPTRateUser != _ptRate) {
            ptRateOfUser[_user] = _ptRate;
        }

        // Check for skipping yield update when the user deposits for the first time or rates decreased to 0.
        if (_oldIBTRateUser != 0) {
            updatedUserYieldInIBT = PrincipalTokenUtil._computeYield(
                _user,
                yieldOfUserInIBT[_user],
                _oldIBTRateUser,
                _ibtRate,
                _oldPTRateUser,
                _ptRate,
                yt
            );
            yieldOfUserInIBT[_user] = updatedUserYieldInIBT;
            emit YieldUpdated(_user, updatedUserYieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-updateYield.txt
claimYield:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function claimYield(address _receiver) public override returns (uint256 yieldInAsset) {
        uint256 yieldInIBT = _claimYield();
        if (yieldInIBT != 0) {
            yieldInAsset = IERC4626(ibt).redeem(yieldInIBT, _receiver, address(this));
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimYield.txt
claimYieldInIBT:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function claimYieldInIBT(address _receiver) public override returns (uint256 yieldInIBT) {
        yieldInIBT = _claimYield();
        if (yieldInIBT != 0) {
            IERC20(ibt).safeTransfer(_receiver, yieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimYieldInIBT.txt
beforeYtTransfer:
yt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:yt
function state variables written:
    function beforeYtTransfer(address _from, address _to) external override {
        if (msg.sender != yt) {
            revert UnauthorizedCaller();
        }
        updateYield(_from);
        updateYield(_to);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-beforeYtTransfer.txt
claimRewards:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function claimRewards
rewardsProxy
there may be a problem : Comparison statement order adjustment in claimRewards
there may be a problem : Do not declare local variables used only once in claimRewards
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in claimRewards
['2.11', '1.1', '4.1', '2.7', '3.5', '3.2', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    5.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    6.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    7.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    8.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:success
function state variables read:rewardsProxy
function state variables written:
    function claimRewards(bytes memory _data) external restricted {
        if (rewardsProxy == address(0)) {
            revert NoRewardsProxySet();
        }
        _data = abi.encodeWithSelector(IRewardsProxy(rewardsProxy).claimRewards.selector, _data);
        (bool success, ) = rewardsProxy.delegatecall(_data);
        if (!success) {
            revert ClaimRewardsFailed();
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimRewards.txt
storeRatesAtExpiry:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function storeRatesAtExpiry
ibtRate, ptRate, ratesAtExpiryStored
there may be a problem : check before updating state variable with same value in storeRatesAtExpiry
there may be a problem : check before updating state variable with same value in storeRatesAtExpiry
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in storeRatesAtExpiry
['2.11', '1.1', '4.1', '3.2', '2.4', '3.6', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    7.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:ibtRate, ptRate, ratesAtExpiryStored
function state variables written:ibtRate, ptRate, ratesAtExpiryStored
    function storeRatesAtExpiry() public override afterExpiry {
        if (ratesAtExpiryStored) {
            revert RatesAtExpiryAlreadyStored();
        }
        ratesAtExpiryStored = true;
        // PT rate not rounded up here
        (ptRate, ibtRate) = _getCurrentPTandIBTRates(false);
        emit RatesStoredAtExpiry(ibtRate, ptRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-storeRatesAtExpiry.txt
setRewardsProxy:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function setRewardsProxy
rewardsProxy
there may be a problem : check before updating state variable with same value in setRewardsProxy
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in setRewardsProxy
['2.11', '1.1', '4.1', '3.2', '2.4', '3.6', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    7.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:rewardsProxy
function state variables written:rewardsProxy
    function setRewardsProxy(address _rewardsProxy) external restricted {
        // Note: address zero is allowed in order to disable the claim proxy
        emit RewardsProxyChange(rewardsProxy, _rewardsProxy);
        rewardsProxy = _rewardsProxy;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-setRewardsProxy.txt
previewDeposit:
ibt
there may be a problem : Do not declare local variables used only once in previewDeposit
['2.11', '4.1', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:ibts
function state variables read:ibt
function state variables written:
    function previewDeposit(uint256 assets) public view override returns (uint256) {
        uint256 ibts = IERC4626(ibt).previewDeposit(assets);
        return _previewDepositIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewDeposit.txt
previewDepositIBT:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewDepositIBT(uint256 ibts) external view override returns (uint256) {
        return _previewDepositIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewDepositIBT.txt
maxDeposit:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxDeposit(address) external pure override returns (uint256) {
        return type(uint256).max;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxDeposit.txt
previewWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewWithdraw
ibt
there may be a problem : Do not declare local variables used only once in previewWithdraw
['2.11', '1.1', '4.1', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:ibts
function state variables read:ibt
function state variables written:
    function previewWithdraw(
        uint256 assets
    ) external view override whenNotPaused returns (uint256) {
        uint256 ibts = IERC4626(ibt).previewWithdraw(assets);
        return previewWithdrawIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewWithdraw.txt
previewWithdrawIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewWithdrawIBT

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewWithdrawIBT(uint256 ibts) public view override whenNotPaused returns (uint256) {
        return _convertIBTsToShares(ibts, true);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewWithdrawIBT.txt
maxWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function maxWithdraw

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxWithdraw(address owner) public view override whenNotPaused returns (uint256) {
        return convertToUnderlying(_maxBurnable(owner));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxWithdraw.txt
maxWithdrawIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function maxWithdrawIBT

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxWithdrawIBT(address owner) public view override whenNotPaused returns (uint256) {
        return _convertSharesToIBTs(_maxBurnable(owner), false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxWithdrawIBT.txt
previewRedeem:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function previewRedeem(uint256 shares) public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(previewRedeemForIBT(shares));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewRedeem.txt
previewRedeemForIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewRedeemForIBT

['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewRedeemForIBT(
        uint256 shares
    ) public view override whenNotPaused returns (uint256) {
        return _convertSharesToIBTs(shares, false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewRedeemForIBT.txt
maxRedeem:

['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxRedeem(address owner) public view override returns (uint256) {
        return _maxBurnable(owner);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxRedeem.txt
convertToPrincipal:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function convertToPrincipal(uint256 underlyingAmount) external view override returns (uint256) {
        return _convertIBTsToShares(IERC4626(ibt).previewDeposit(underlyingAmount), false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-convertToPrincipal.txt
convertToUnderlying:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function convertToUnderlying(uint256 principalAmount) public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(_convertSharesToIBTs(principalAmount, false));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-convertToUnderlying.txt
totalAssets:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function totalAssets() public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(IERC4626(ibt).balanceOf(address(this)));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-totalAssets.txt
decimals:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {
        return IERC4626(ibt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-decimals.txt
underlying:
_asset
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:_asset
function state variables written:
    function underlying() external view override returns (address) {
        return _asset;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-underlying.txt
maturity:
expiry
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:expiry
function state variables written:
    function maturity() external view override returns (uint256) {
        return expiry;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maturity.txt
getDuration:
duration
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:duration
function state variables written:
    function getDuration() external view override returns (uint256) {
        return duration;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getDuration.txt
getIBT:
ibt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function getIBT() external view override returns (address) {
        return ibt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBT.txt
getYT:
yt
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:yt
function state variables written:
    function getYT() external view override returns (address) {
        return yt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getYT.txt
getIBTRate:

there may be a problem : Do not declare local variables used only once in getIBTRate
['2.11', '4.1', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:_ibtRate
function state variables read:
function state variables written:
    function getIBTRate() external view override returns (uint256) {
        (, uint256 _ibtRate) = _getPTandIBTRates(false);
        return _ibtRate;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBTRate.txt
getPTRate:

there may be a problem : Do not declare local variables used only once in getPTRate
['2.11', '4.1', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:_ptRate
function state variables read:
function state variables written:
    function getPTRate() external view override returns (uint256) {
        (uint256 _ptRate, ) = _getPTandIBTRates(false);
        return _ptRate;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getPTRate.txt
getIBTUnit:
ibtUnit
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibtUnit
function state variables written:
    function getIBTUnit() external view override returns (uint256) {
        return ibtUnit;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBTUnit.txt
getUnclaimedFeesInIBT:
unclaimedFeesInIBT
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:unclaimedFeesInIBT
function state variables written:
    function getUnclaimedFeesInIBT() external view override returns (uint256) {
        return unclaimedFeesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getUnclaimedFeesInIBT.txt
getTotalFeesInIBT:
totalFeesInIBT
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:totalFeesInIBT
function state variables written:
    function getTotalFeesInIBT() external view override returns (uint256) {
        return totalFeesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getTotalFeesInIBT.txt
getCurrentYieldOfUserInIBT:
ibtRateOfUser, ptRateOfUser, registry, yieldOfUserInIBT, yt
there may be a problem : Comparison statement order adjustment in getCurrentYieldOfUserInIBT
there may be a problem : Comparison statement order adjustment in getCurrentYieldOfUserInIBT
there may be a problem : Comparison statement order adjustment in getCurrentYieldOfUserInIBT
there may be a problem : ++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1) in function getCurrentYieldOfUserInIBT
there may be a problem : Do not declare local variables used only once in getCurrentYieldOfUserInIBT
['2.11', '4.1', '2.7', '3.5', '2.3', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1)
You find that unsigned int increases or decreases, and you can change i++ and i+=1 into ++i, i-- the same thing. While, there will be some situations you don't need to change. For example, a = i++; or a = functionA(i++);.
    6.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    7.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:_ptRate, _ibtRate, _oldPTRate
function state variables read:ibtRateOfUser, ptRateOfUser, registry, yieldOfUserInIBT, yt
function state variables written:
    function getCurrentYieldOfUserInIBT(
        address _user
    ) external view override returns (uint256 _yieldOfUserInIBT) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 _oldIBTRate = ibtRateOfUser[_user];
        uint256 _oldPTRate = ptRateOfUser[_user];
        if (_oldIBTRate != 0) {
            _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
                _user,
                yieldOfUserInIBT[_user],
                _oldIBTRate,
                _ibtRate,
                _oldPTRate,
                _ptRate,
                yt
            );
            _yieldOfUserInIBT -= PrincipalTokenUtil._computeYieldFee(_yieldOfUserInIBT, registry);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getCurrentYieldOfUserInIBT.txt
maxFlashLoan:
ibt
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in maxFlashLoan
['2.11', '4.1', '2.4', '3.2', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function maxFlashLoan(address _token) public view override returns (uint256) {
        if (_token != ibt) {
            return 0;
        }
        // Entire IBT balance of the contract can be borrowed
        return IERC4626(ibt).balanceOf(address(this));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxFlashLoan.txt
flashFee:
ibt, registry
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt, registry
function state variables written:
    function flashFee(address _token, uint256 _amount) public view override returns (uint256) {
        if (_token != ibt) revert AddressError();
        return PrincipalTokenUtil._computeFlashloanFee(_amount, registry);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-flashFee.txt
getTokenizationFee:
registry
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:registry
function state variables written:
    function getTokenizationFee() public view override returns (uint256) {
        return IRegistry(registry).getTokenizationFee();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getTokenizationFee.txt
flashLoan:
ON_FLASH_LOAN, ibt
there may be a problem : Comparison statement order adjustment in flashLoan
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in flashLoan
['2.11', '4.1', '2.7', '3.2', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:ON_FLASH_LOAN, ibt
function state variables written:
    function flashLoan(
        IERC3156FlashBorrower _receiver,
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external override returns (bool) {
        if (_amount > maxFlashLoan(_token)) revert FlashLoanExceedsMaxAmount();

        uint256 fee = flashFee(_token, _amount);
        _updateFees(fee);

        // Initiate the flash loan by lending the requested IBT amount
        IERC20(ibt).safeTransfer(address(_receiver), _amount);

        // Execute the flash loan
        if (_receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) != ON_FLASH_LOAN)
            revert FlashLoanCallbackFailed();

        // Repay the debt + fee
        IERC20(ibt).safeTransferFrom(address(_receiver), address(this), _amount + fee);

        return true;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-flashLoan.txt
_previewDepositIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function _previewDepositIBT
registry
there may be a problem : Do not declare local variables used only once in _previewDepositIBT
['2.11', '1.1', '4.1', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:tokenizationFee
function state variables read:registry
function state variables written:
    function _previewDepositIBT(
        uint256 _ibts
    ) internal view notExpired whenNotPaused returns (uint256) {
        uint256 tokenizationFee = PrincipalTokenUtil._computeTokenizationFee(
            _ibts,
            address(this),
            registry
        );

        return _convertIBTsToSharesPreview(_ibts - tokenizationFee);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_previewDepositIBT.txt
_convertSharesToIBTs:

there may be a problem : Comparison statement order adjustment in _convertSharesToIBTs
there may be a problem : Comparison statement order adjustment in _convertSharesToIBTs
there may be a problem : Comparison statement order adjustment in _convertSharesToIBTs
['2.11', '4.1', '2.7', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function _convertSharesToIBTs(
        uint256 _shares,
        bool _roundUp
    ) internal view returns (uint256 ibts) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        if (_ibtRate == 0) {
            revert RateError();
        }
        ibts = _shares.mulDiv(
            _ptRate,
            _ibtRate,
            _roundUp ? Math.Rounding.Ceil : Math.Rounding.Floor
        );
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_convertSharesToIBTs.txt
_convertIBTsToShares:

there may be a problem : Comparison statement order adjustment in _convertIBTsToShares
there may be a problem : Comparison statement order adjustment in _convertIBTsToShares
there may be a problem : Comparison statement order adjustment in _convertIBTsToShares
['2.11', '4.1', '2.7', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function _convertIBTsToShares(
        uint256 _ibts,
        bool _roundUp
    ) internal view returns (uint256 shares) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        if (_ptRate == 0) {
            revert RateError();
        }
        shares = _ibts.mulDiv(
            _ibtRate,
            _ptRate,
            _roundUp ? Math.Rounding.Ceil : Math.Rounding.Floor
        );
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_convertIBTsToShares.txt
_convertIBTsToSharesPreview:

there may be a problem : Comparison statement order adjustment in _convertIBTsToSharesPreview
there may be a problem : Do not declare local variables used only once in _convertIBTsToSharesPreview
['2.11', '4.1', '2.7', '3.5', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
variable used once:_ibtRate
function state variables read:
function state variables written:
    function _convertIBTsToSharesPreview(uint256 ibts) internal view returns (uint256 shares) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(true); // to round up the shares, the PT rate must round down
        if (_ptRate == 0) {
            revert RateError();
        }
        shares = ibts.mulDiv(_ibtRate, _ptRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_convertIBTsToSharesPreview.txt
_updateFees:
totalFeesInIBT, unclaimedFeesInIBT
there may be a problem : ++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1) in function _updateFees
there may be a problem : a = a + b is more gas effective than a += b for state variables in _updateFees
there may be a problem : check before updating state variable with same value in _updateFees
there may be a problem : ++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1) in function _updateFees
there may be a problem : a = a + b is more gas effective than a += b for state variables in _updateFees
there may be a problem : check before updating state variable with same value in _updateFees
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in _updateFees
['2.11', '4.1', '2.3', '3.2', '2.8', '2.4', '3.6', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1)
You find that unsigned int increases or decreases, and you can change i++ and i+=1 into ++i, i-- the same thing. While, there will be some situations you don't need to change. For example, a = i++; or a = functionA(i++);.
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.a = a + b is more gas effective than a += b for state variables(excluding mapping and arrays)
You first need to determine where the state variable(not an array or mapping) is written in the code, and when the state variable executes a+=b statement, you need to change it to a=a+b statement to save gas.
    6.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    7.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    8.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:totalFeesInIBT, unclaimedFeesInIBT
function state variables written:totalFeesInIBT, unclaimedFeesInIBT
    function _updateFees(uint256 _feesInIBT) internal {
        unclaimedFeesInIBT += _feesInIBT;
        totalFeesInIBT += _feesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_updateFees.txt
_deployYT:
there may be a problem : Avoid declaring unused variables or unused internal function in function _deployYT
registry
there may be a problem : Use calldata instead of memory for function arguments that do not get mutated in _deployYT
['2.11', '4.1', '2.4', '2.2', '3.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    4.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    5.Use calldata instead of memory for function arguments that do not get mutated
You should first find function arguments that do not need to be changed within the function. If its type is memory, you mark the data type as calldata. But its type is not memory(such as byte32 or address), skip it.
    
solidity version :0.8.20
function state variables read:registry
function state variables written:
    function _deployYT(string memory _name, string memory _symbol) internal returns (address _yt) {
        address ytBeacon = IRegistry(registry).getYTBeacon();
        if (ytBeacon == address(0)) {
            revert BeaconNotSet();
        }
        _yt = address(
            new BeaconProxy(
                ytBeacon,
                abi.encodeWithSelector(
                    IYieldToken(address(0)).initialize.selector,
                    _name,
                    _symbol,
                    address(this)
                )
            )
        );
        emit YTDeployed(_yt);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_deployYT.txt
_depositIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function _depositIBT
registry, yt
['2.11', '1.1', '4.1', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:registry, yt
function state variables written:
    function _depositIBT(
        uint256 _ibts,
        address _ptReceiver,
        address _ytReceiver
    ) internal notExpired nonReentrant whenNotPaused returns (uint256 shares) {
        updateYield(_ytReceiver);
        uint256 tokenizationFee = PrincipalTokenUtil._computeTokenizationFee(
            _ibts,
            address(this),
            registry
        );
        _updateFees(tokenizationFee);
        shares = _convertIBTsToShares(_ibts - tokenizationFee, false);
        if (shares == 0) {
            revert RateError();
        }
        _mint(_ptReceiver, shares);
        emit Mint(msg.sender, _ptReceiver, shares);
        IYieldToken(yt).mint(_ytReceiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_depositIBT.txt
_withdrawShares:
there may be a problem : Avoid declaring unused variables or unused internal function in function _withdrawShares
expiry, yt
there may be a problem : Comparison statement order adjustment in _withdrawShares
['2.11', '4.1', '2.7', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:expiry, yt
function state variables written:
    function _withdrawShares(
        uint256 _ibts,
        address _receiver,
        address _owner,
        uint256 _ptRate,
        uint256 _ibtRate
    ) internal returns (uint256 shares) {
        if (_ptRate == 0) {
            revert RateError();
        }
        // convert ibts to shares using provided rates
        shares = _ibts.mulDiv(_ibtRate, _ptRate, Math.Rounding.Ceil);
        // burn owner's shares (YT and PT)
        if (block.timestamp < expiry) {
            IYieldToken(yt).burnWithoutUpdate(_owner, shares);
        }
        _burn(_owner, shares);
        emit Redeem(_owner, _receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_withdrawShares.txt
_beforeRedeem:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function _beforeRedeem
expiry, ratesAtExpiryStored, yt
there may be a problem : Comparison statement order adjustment in _beforeRedeem
['2.11', '1.1', '4.1', '2.7', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:expiry, ratesAtExpiryStored, yt
function state variables written:
    function _beforeRedeem(uint256 _shares, address _owner) internal nonReentrant whenNotPaused {
        if (_owner != msg.sender) {
            revert UnauthorizedCaller();
        }
        if (_shares > _maxBurnable(_owner)) {
            revert UnsufficientBalance();
        }
        if (block.timestamp >= expiry) {
            if (!ratesAtExpiryStored) {
                storeRatesAtExpiry();
            }
        } else {
            updateYield(_owner);
            IYieldToken(yt).burnWithoutUpdate(_owner, _shares);
        }
        _burn(_owner, _shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_beforeRedeem.txt
_beforeWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function _beforeWithdraw
expiry, ratesAtExpiryStored
there may be a problem : Comparison statement order adjustment in _beforeWithdraw
['2.11', '1.1', '4.1', '2.7', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:expiry, ratesAtExpiryStored
function state variables written:
    function _beforeWithdraw(uint256 _assets, address _owner) internal whenNotPaused nonReentrant {
        if (_owner != msg.sender) {
            revert UnauthorizedCaller();
        }
        if (block.timestamp >= expiry) {
            if (!ratesAtExpiryStored) {
                storeRatesAtExpiry();
            }
        } else {
            updateYield(_owner);
        }
        if (maxWithdraw(_owner) < _assets) {
            revert UnsufficientBalance();
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_beforeWithdraw.txt
_claimYield:
registry
there may be a problem : check before updating state variable with same value in _claimYield
there may be a problem : ++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1) in function _claimYield
['2.11', '4.1', '2.3', '2.4', '3.6', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1)
You find that unsigned int increases or decreases, and you can change i++ and i+=1 into ++i, i-- the same thing. While, there will be some situations you don't need to change. For example, a = i++; or a = functionA(i++);.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    6.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:registry
function state variables written:yieldOfUserInIBT
    function _claimYield() internal returns (uint256 yieldInIBT) {
        yieldInIBT = updateYield(msg.sender);
        if (yieldInIBT == 0) {
            return 0;
        } else {
            yieldOfUserInIBT[msg.sender] = 0;
            uint256 yieldFeeInIBT = PrincipalTokenUtil._computeYieldFee(yieldInIBT, registry);
            _updateFees(yieldFeeInIBT);
            yieldInIBT -= yieldFeeInIBT;
            emit YieldClaimed(msg.sender, msg.sender, yieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_claimYield.txt
_maxBurnable:
expiry, yt
there may be a problem : Comparison statement order adjustment in _maxBurnable
['2.11', '4.1', '2.7', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    5.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:expiry, yt
function state variables written:
    function _maxBurnable(address _user) internal view returns (uint256 maxBurnable) {
        if (block.timestamp >= expiry) {
            maxBurnable = balanceOf(_user);
        } else {
            uint256 ptBalance = balanceOf(_user);
            uint256 ytBalance = IYieldToken(yt).balanceOf(_user);
            maxBurnable = (ptBalance > ytBalance) ? ytBalance : ptBalance;
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_maxBurnable.txt
_updatePTandIBTRates:
expiry, ibtRate, ptRate, ratesAtExpiryStored
there may be a problem : check before updating state variable with same value in _updatePTandIBTRates
there may be a problem : check before updating state variable with same value in _updatePTandIBTRates
there may be a problem : Comparison statement order adjustment in _updatePTandIBTRates
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in _updatePTandIBTRates
['2.11', '4.1', '2.7', '3.2', '2.4', '3.6', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    6.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    7.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:expiry, ibtRate, ptRate, ratesAtExpiryStored
function state variables written:ibtRate, ptRate
    function _updatePTandIBTRates() internal returns (uint256 _ptRate, uint256 _ibtRate) {
        if (block.timestamp >= expiry) {
            if (!ratesAtExpiryStored) {
                storeRatesAtExpiry();
            }
        }
        (_ptRate, _ibtRate) = _getPTandIBTRates(false);
        if (block.timestamp < expiry) {
            if (_ibtRate != ibtRate) {
                ibtRate = _ibtRate;
            }
            if (_ptRate != ptRate) {
                ptRate = _ptRate;
            }
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_updatePTandIBTRates.txt
_getCurrentPTandIBTRates:
_assetDecimals, ibt, ibtRate, ibtUnit, ptRate
there may be a problem : Splitting require() statements that use && saves gas in _getCurrentPTandIBTRates
there may be a problem : Comparison statement order adjustment in _getCurrentPTandIBTRates
there may be a problem : Comparison statement order adjustment in _getCurrentPTandIBTRates
there may be a problem : Comparison statement order adjustment in _getCurrentPTandIBTRates
there may be a problem : Comparison statement order adjustment in _getCurrentPTandIBTRates
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in _getCurrentPTandIBTRates
['2.11', '4.1', '2.7', '2.1', '3.2', '2.4', '2.2']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    4.Splitting require() statements that use && saves gas.
When you find that the require statement's judgement has a continuous judgement of &&, you can split it into multiple require statements to save gas.
    example:
-    require(amount > 0 && amount <= getMaxTransactionAmount() && isTransactionAllowed(), "Invalid transaction");
+    require(amount > 0, "Invalid transaction");
+    require(amount <= getMaxTransactionAmount(), "Invalid transaction");
+    require(isTransactionAllowed(), "Invalid transaction");
    5.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    6.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    7.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    
solidity version :0.8.20
function state variables read:_assetDecimals, ibt, ibtRate, ibtUnit, ptRate
function state variables written:
    function _getCurrentPTandIBTRates(bool roundUpPTRate) internal view returns (uint256, uint256) {
        uint256 currentIBTRate = IERC4626(ibt).previewRedeem(ibtUnit).toRay(_assetDecimals);
        if (IERC4626(ibt).totalAssets() == 0 && IERC4626(ibt).totalSupply() != 0) {
            currentIBTRate = 0;
        }
        uint256 currentPTRate = currentIBTRate < ibtRate
            ? ptRate.mulDiv(
                currentIBTRate,
                ibtRate,
                roundUpPTRate ? Math.Rounding.Ceil : Math.Rounding.Floor
            )
            : ptRate;
        return (currentPTRate, currentIBTRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_getCurrentPTandIBTRates.txt
_getPTandIBTRates:
ibtRate, ptRate, ratesAtExpiryStored
['2.11', '2.4', '2.2', '4.1']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibtRate, ptRate, ratesAtExpiryStored
function state variables written:
    function _getPTandIBTRates(bool roundUpPTRate) internal view returns (uint256, uint256) {
        if (ratesAtExpiryStored) {
            return (ptRate, ibtRate);
        } else {
            return _getCurrentPTandIBTRates(roundUpPTRate);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_getPTandIBTRates.txt
slitherConstructorConstantVariables:
there may be a problem : State variables only set in the constructor should be declared immutable in PrincipalToken
there may be a problem : Pack the variables into fewer storage slots by re-ordering the variables or reducing their sizes in PrincipalToken
there may be a problem : Using bools for storage incurs overhead in PrincipalToken
['3.7', '2.5', '3.3', '3.4']
hint message:
1.Using bools for storage incurs overhead,instead use uint256
You first need to find those state variables that refer to bool. To mitigate these gas costs, you can utilize uint256 values uint256(1) and uint256(2) to represent true and false respectively including the variables in mapping.
    2.Using private rather than public for constants saves gas
You first need to find the variables with public and constant modifier, then convert it to private and rememeber to set the relevant read function to let the external contract read it.
-    uint256 public constant GAS_CONSTANT_A = 123;
-    uint256 public constant GAS_CONSTANT_B = 456;
+    uint256 private constant GAS_CONSTANT_A = 123;
+    uint256 private constant GAS_CONSTANT_B = 456;

+    function getAllPublicConstants() external pure returns (uint256, uint256) {
+        return (GAS_CONSTANT_A, GAS_CONSTANT_B);
+    }
    3.State variables only set in the constructor should be declared immutable & Use immutables variables directly instead of caching them in stack.
You should first find the variables set only in constructor and then set them immutable.
    4.Pack the variables into fewer storage slots by re-ordering the variables or reducing their sizes
You should first determine whether there is a situation in which these variables can reduce size, such as some variables about time, and then after reducing size of the variable, you need to determine whether you can adjust the order of the variables to make storage more space-saving. And of course you also have to think about what's going on inside the struct.
    exmaple:
-    uint256 public LastDistribution;
    uint256 public MinDistributionPeriod;
+    uint48 public LastDistribution;
    bool public LockedForDistribution;
    LastDistribution can be reduced to uint48 since it holds block number so uint48 is more than sufficient to hold any realistic block number of any blockchain.
    
content:
solidity version :0.8.20
variable written only construct:['registry']
contract PrincipalToken is
    ERC20PermitUpgradeable,
    AccessManagedUpgradeable,
    ReentrancyGuardUpgradeable,
    PausableUpgradeable,
    IPrincipalToken
{
    using SafeERC20 for IERC20;
    using RayMath for uint256;
    using Math for uint256;
    uint256 private constant MIN_DECIMALS = 6;
    uint256 private constant MAX_DECIMALS = 18;
    bytes32 private constant ON_FLASH_LOAN = keccak256("ERC3156FlashBorrower.onFlashLoan");
    address private immutable registry;
    address private rewardsProxy;
    bool private ratesAtExpiryStored;
    address private ibt; // address of the Interest Bearing Token 4626 held by this PT vault
    address private _asset; // the asset of this PT vault (which is also the asset of the IBT 4626)
    address private yt; // YT corresponding to this PT, deployed at initialization
    uint256 private ibtUnit; // equal to one unit of the IBT held by this PT vault (10^decimals)
    uint256 private _ibtDecimals;
    uint256 private _assetDecimals;
    uint256 private ptRate; // or PT price in asset (in Ray)
    uint256 private ibtRate; // or IBT price in asset (in Ray)
    uint256 private unclaimedFeesInIBT; // unclaimed fees
    uint256 private totalFeesInIBT; // total fees
    uint256 private expiry; // date of maturity (set at initialization)
    uint256 private duration; // duration to maturity
    mapping(address => uint256) private ibtRateOfUser; // stores each user's IBT rate (in Ray)
    mapping(address => uint256) private ptRateOfUser; // stores each user's PT rate (in Ray)
    mapping(address => uint256) private yieldOfUserInIBT; // stores each user's yield generated from YTs
        address indexed user,
        uint256 indexed redeemedIbts,
        uint256 indexed receivedAssets
    );
    modifier notExpired() virtual {
        if (block.timestamp >= expiry) {
            revert PTExpired();
        }
        _;
    }
    modifier afterExpiry() virtual {
        if (block.timestamp < expiry) {
            revert PTNotExpired();
        }
        _;
    }
    constructor(address _registry) {
        if (_registry == address(0)) {
            revert AddressError();
        }
        registry = _registry;
        _disableInitializers(); // using this so that the deployed logic contract cannot later be initialized
    }

path:
/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken.txt
Command executed successfully. Output saved to ./function-summary.txt
YieldToken:
__ERC20Permit_init:
__ERC20Permit_init_unchained:
permit:
nonces:
DOMAIN_SEPARATOR:
_getNoncesStorage:
__Nonces_init:
__Nonces_init_unchained:
nonces:
_useNonce:
_useCheckedNonce:
_checkInitializing:
_disableInitializers:
_getInitializedVersion:
_isInitializing:
_getInitializableStorage:
_getEIP712Storage:
__EIP712_init:
__EIP712_init_unchained:
_domainSeparatorV4:
_buildDomainSeparator:
_hashTypedDataV4:
eip712Domain:
_EIP712Name:
_EIP712Version:
_EIP712NameHash:
_EIP712VersionHash:
eip712Domain:
permit:
nonces:
DOMAIN_SEPARATOR:
_getERC20Storage:
__ERC20_init:
__ERC20_init_unchained:
name:
symbol:
decimals:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals()
        public
        view
        virtual
        override(IYieldToken, ERC20Upgradeable)
        returns (uint8)
    {
        return IERC20Metadata(pt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-decimals.txt
totalSupply:
balanceOf:

there may be a problem : Do not declare local variables used only once in balanceOf
['2.2', '2.4', '2.11', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:$
function state variables read:
function state variables written:
    function balanceOf(
        address account
    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {
        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-balanceOf.txt
transfer:

there may be a problem : Do not declare local variables used only once in transfer
['2.2', '2.4', '2.11', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:owner
function state variables read:
function state variables written:
    function transfer(
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);
        return super.transfer(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transfer.txt
allowance:
approve:
transferFrom:

there may be a problem : Do not declare local variables used only once in transferFrom
['2.2', '2.4', '2.11', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:spender
function state variables read:
function state variables written:
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(from, to);
        return super.transferFrom(from, to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transferFrom.txt
_transfer:
_update:
_mint:
_burn:
_approve:
_approve:
_spendAllowance:
name:
symbol:
decimals:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals()
        public
        view
        virtual
        override(IYieldToken, ERC20Upgradeable)
        returns (uint8)
    {
        return IERC20Metadata(pt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-decimals.txt
totalSupply:
balanceOf:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function balanceOf(
        address account
    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {
        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-balanceOf.txt
transfer:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function transfer(
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);
        return super.transfer(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transfer.txt
allowance:
approve:
transferFrom:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(from, to);
        return super.transferFrom(from, to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transferFrom.txt
__Context_init:
__Context_init_unchained:
_msgSender:
_msgData:
_contextSuffixLength:
initialize:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function initialize

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function initialize(
        string calldata _name,
        string calldata _symbol,
        address _pt
    ) external initializer {
        __ERC20_init(_name, _symbol);
        __ERC20Permit_init(_name);
        pt = _pt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-initialize.txt
decimals:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals()
        public
        view
        virtual
        override(IYieldToken, ERC20Upgradeable)
        returns (uint8)
    {
        return IERC20Metadata(pt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-decimals.txt
getPT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getPT() public view virtual override returns (address) {
        return pt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-getPT.txt
transfer:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function transfer(
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);
        return super.transfer(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transfer.txt
transferFrom:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(from, to);
        return super.transferFrom(from, to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transferFrom.txt
burnWithoutUpdate:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function burnWithoutUpdate(address from, uint256 amount) external override {
        if (msg.sender != pt) {
            revert CallerIsNotPtContract();
        }
        _burn(from, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-burnWithoutUpdate.txt
mint:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function mint(address to, uint256 amount) external override {
        if (msg.sender != pt) {
            revert CallerIsNotPtContract();
        }
        _mint(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-mint.txt
burn:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function burn(uint256 amount) public override {
        IPrincipalToken(pt).updateYield(msg.sender);
        _burn(msg.sender, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-burn.txt
balanceOf:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function balanceOf(
        address account
    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {
        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-balanceOf.txt
actualBalanceOf:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function actualBalanceOf(address account) public view override returns (uint256) {
        return super.balanceOf(account);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-actualBalanceOf.txt
constructor:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    constructor() {
        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-constructor.txt
initialize:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function initialize

there may be a problem : check before updating state variable with same value in initialize
['2.2', '2.4', '3.6', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:pt
    function initialize(
        string calldata _name,
        string calldata _symbol,
        address _pt
    ) external initializer {
        __ERC20_init(_name, _symbol);
        __ERC20Permit_init(_name);
        pt = _pt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-initialize.txt
burnWithoutUpdate:
pt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function burnWithoutUpdate(address from, uint256 amount) external override {
        if (msg.sender != pt) {
            revert CallerIsNotPtContract();
        }
        _burn(from, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-burnWithoutUpdate.txt
mint:
pt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function mint(address to, uint256 amount) external override {
        if (msg.sender != pt) {
            revert CallerIsNotPtContract();
        }
        _mint(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-mint.txt
burn:
pt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function burn(uint256 amount) public override {
        IPrincipalToken(pt).updateYield(msg.sender);
        _burn(msg.sender, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-burn.txt
transfer:
pt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function transfer(
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(msg.sender, to);
        return super.transfer(to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transfer.txt
transferFrom:
pt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function transferFrom(
        address from,
        address to,
        uint256 amount
    ) public virtual override(IYieldToken, ERC20Upgradeable) returns (bool success) {
        IPrincipalToken(pt).beforeYtTransfer(from, to);
        return super.transferFrom(from, to, amount);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-transferFrom.txt
decimals:
pt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function decimals()
        public
        view
        virtual
        override(IYieldToken, ERC20Upgradeable)
        returns (uint8)
    {
        return IERC20Metadata(pt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-decimals.txt
getPT:
pt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function getPT() public view virtual override returns (address) {
        return pt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-getPT.txt
balanceOf:
pt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:pt
function state variables written:
    function balanceOf(
        address account
    ) public view override(IYieldToken, ERC20Upgradeable) returns (uint256) {
        return (block.timestamp < IPrincipalToken(pt).maturity()) ? super.balanceOf(account) : 0;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-balanceOf.txt
actualBalanceOf:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function actualBalanceOf(address account) public view override returns (uint256) {
        return super.balanceOf(account);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken-actualBalanceOf.txt
there may be a problem : Pack the variables into fewer storage slots by re-ordering the variables or reducing their sizes in YieldToken
there may be a problem : Using bools for storage incurs overhead in YieldToken
['3.4', '3.7']
hint message:
1.Pack the variables into fewer storage slots by re-ordering the variables or reducing their sizes
You should first determine whether there is a situation in which these variables can reduce size, such as some variables about time, and then after reducing size of the variable, you need to determine whether you can adjust the order of the variables to make storage more space-saving. And of course you also have to think about what's going on inside the struct.
    exmaple:
-    uint256 public LastDistribution;
    uint256 public MinDistributionPeriod;
+    uint48 public LastDistribution;
    bool public LockedForDistribution;
    LastDistribution can be reduced to uint48 since it holds block number so uint48 is more than sufficient to hold any realistic block number of any blockchain.
    2.Using bools for storage incurs overhead,instead use uint256
You first need to find those state variables that refer to bool. To mitigate these gas costs, you can utilize uint256 values uint256(1) and uint256(2) to represent true and false respectively including the variables in mapping.
    
content:
solidity version :0.8.20
variable written only construct:[]
contract YieldToken is IYieldToken, ERC20PermitUpgradeable {
    using Math for uint256;
    address private pt;
    constructor() {
        _disableInitializers(); // using this so that the deployed logic contract later cannot be initialized.
    }

path:
/nasdata/ruanyijie/gas_optimization/src/result/spectra/YieldToken.txt
PrincipalToken:
initialize:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function initialize

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function initialize(
        address _ibt,
        uint256 _duration,
        address _initialAuthority
    ) external initializer {
        if (_ibt == address(0) || _initialAuthority == address(0)) {
            revert AddressError();
        }
        if (IERC4626(_ibt).totalAssets() == 0) {
            revert RateError();
        }
        _asset = IERC4626(_ibt).asset();
        duration = _duration;
        expiry = _duration + block.timestamp;
        string memory _ibtSymbol = IERC4626(_ibt).symbol();
        string memory name = NamingUtil.genPTName(_ibtSymbol, expiry);
        __ERC20_init(name, NamingUtil.genPTSymbol(_ibtSymbol, expiry));
        __ERC20Permit_init(name);
        __Pausable_init();
        __ReentrancyGuard_init();
        __AccessManaged_init(_initialAuthority);
        _ibtDecimals = IERC4626(_ibt).decimals();
        _assetDecimals = PrincipalTokenUtil._tryGetTokenDecimals(_asset);
        if (
            _assetDecimals < MIN_DECIMALS ||
            _assetDecimals > _ibtDecimals ||
            _ibtDecimals > MAX_DECIMALS
        ) {
            revert InvalidDecimals();
        }
        ibt = _ibt;
        ibtUnit = 10 ** _ibtDecimals;
        ibtRate = IERC4626(ibt).previewRedeem(ibtUnit).toRay(_assetDecimals);
        ptRate = RayMath.RAY_UNIT;
        yt = _deployYT(
            NamingUtil.genYTName(_ibtSymbol, expiry),
            NamingUtil.genYTSymbol(_ibtSymbol, expiry)
        );
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-initialize.txt
pause:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function pause

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function pause() external override restricted {
        _pause();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-pause.txt
unPause:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function unPause

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function unPause() external override restricted {
        _unpause();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-unPause.txt
deposit:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
deposit:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
deposit:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
depositIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
depositIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
depositIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
redeem:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 assets) {
        _beforeRedeem(shares, owner);
        assets = IERC4626(ibt).redeem(_convertSharesToIBTs(shares, false), receiver, address(this));
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeem.txt
redeem:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 assets) {
        _beforeRedeem(shares, owner);
        assets = IERC4626(ibt).redeem(_convertSharesToIBTs(shares, false), receiver, address(this));
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeem.txt
redeemForIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeemForIBT(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 ibts) {
        _beforeRedeem(shares, owner);
        ibts = _convertSharesToIBTs(shares, false);
        IERC20(ibt).safeTransfer(receiver, ibts);
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeemForIBT.txt
redeemForIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeemForIBT(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 ibts) {
        _beforeRedeem(shares, owner);
        ibts = _convertSharesToIBTs(shares, false);
        IERC20(ibt).safeTransfer(receiver, ibts);
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeemForIBT.txt
withdraw:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(assets, owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 ibts = IERC4626(ibt).withdraw(assets, receiver, address(this));
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdraw.txt
withdraw:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(assets, owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 ibts = IERC4626(ibt).withdraw(assets, receiver, address(this));
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdraw.txt
withdrawIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdrawIBT(
        uint256 ibts,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(IERC4626(ibt).previewRedeem(ibts), owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
        // send IBTs from this contract to receiver
        IERC20(ibt).safeTransfer(receiver, ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdrawIBT.txt
withdrawIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdrawIBT(
        uint256 ibts,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(IERC4626(ibt).previewRedeem(ibts), owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
        // send IBTs from this contract to receiver
        IERC20(ibt).safeTransfer(receiver, ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdrawIBT.txt
updateYield:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function updateYield(address _user) public override returns (uint256 updatedUserYieldInIBT) {
        (uint256 _ptRate, uint256 _ibtRate) = _updatePTandIBTRates();

        uint256 _oldIBTRateUser = ibtRateOfUser[_user];
        if (_oldIBTRateUser != _ibtRate) {
            ibtRateOfUser[_user] = _ibtRate;
        }
        uint256 _oldPTRateUser = ptRateOfUser[_user];
        if (_oldPTRateUser != _ptRate) {
            ptRateOfUser[_user] = _ptRate;
        }

        // Check for skipping yield update when the user deposits for the first time or rates decreased to 0.
        if (_oldIBTRateUser != 0) {
            updatedUserYieldInIBT = PrincipalTokenUtil._computeYield(
                _user,
                yieldOfUserInIBT[_user],
                _oldIBTRateUser,
                _ibtRate,
                _oldPTRateUser,
                _ptRate,
                yt
            );
            yieldOfUserInIBT[_user] = updatedUserYieldInIBT;
            emit YieldUpdated(_user, updatedUserYieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-updateYield.txt
claimYield:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function claimYield(address _receiver) public override returns (uint256 yieldInAsset) {
        uint256 yieldInIBT = _claimYield();
        if (yieldInIBT != 0) {
            yieldInAsset = IERC4626(ibt).redeem(yieldInIBT, _receiver, address(this));
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimYield.txt
claimYieldInIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function claimYieldInIBT(address _receiver) public override returns (uint256 yieldInIBT) {
        yieldInIBT = _claimYield();
        if (yieldInIBT != 0) {
            IERC20(ibt).safeTransfer(_receiver, yieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimYieldInIBT.txt
claimFees:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function claimFees() external override returns (uint256 assets) {
        if (msg.sender != IRegistry(registry).getFeeCollector()) {
            revert UnauthorizedCaller();
        }
        uint256 ibts = unclaimedFeesInIBT;
        unclaimedFeesInIBT = 0;
        assets = IERC4626(ibt).redeem(ibts, msg.sender, address(this));
        emit FeeClaimed(msg.sender, ibts, assets);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimFees.txt
beforeYtTransfer:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function beforeYtTransfer(address _from, address _to) external override {
        if (msg.sender != yt) {
            revert UnauthorizedCaller();
        }
        updateYield(_from);
        updateYield(_to);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-beforeYtTransfer.txt
claimRewards:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function claimRewards

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function claimRewards(bytes memory _data) external restricted {
        if (rewardsProxy == address(0)) {
            revert NoRewardsProxySet();
        }
        _data = abi.encodeWithSelector(IRewardsProxy(rewardsProxy).claimRewards.selector, _data);
        (bool success, ) = rewardsProxy.delegatecall(_data);
        if (!success) {
            revert ClaimRewardsFailed();
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimRewards.txt
storeRatesAtExpiry:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function storeRatesAtExpiry

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function storeRatesAtExpiry() public override afterExpiry {
        if (ratesAtExpiryStored) {
            revert RatesAtExpiryAlreadyStored();
        }
        ratesAtExpiryStored = true;
        // PT rate not rounded up here
        (ptRate, ibtRate) = _getCurrentPTandIBTRates(false);
        emit RatesStoredAtExpiry(ibtRate, ptRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-storeRatesAtExpiry.txt
setRewardsProxy:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function setRewardsProxy

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function setRewardsProxy(address _rewardsProxy) external restricted {
        // Note: address zero is allowed in order to disable the claim proxy
        emit RewardsProxyChange(rewardsProxy, _rewardsProxy);
        rewardsProxy = _rewardsProxy;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-setRewardsProxy.txt
previewDeposit:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewDeposit(uint256 assets) public view override returns (uint256) {
        uint256 ibts = IERC4626(ibt).previewDeposit(assets);
        return _previewDepositIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewDeposit.txt
previewDepositIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewDepositIBT(uint256 ibts) external view override returns (uint256) {
        return _previewDepositIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewDepositIBT.txt
maxDeposit:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxDeposit(address) external pure override returns (uint256) {
        return type(uint256).max;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxDeposit.txt
previewWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewWithdraw

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewWithdraw(
        uint256 assets
    ) external view override whenNotPaused returns (uint256) {
        uint256 ibts = IERC4626(ibt).previewWithdraw(assets);
        return previewWithdrawIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewWithdraw.txt
previewWithdrawIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewWithdrawIBT

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewWithdrawIBT(uint256 ibts) public view override whenNotPaused returns (uint256) {
        return _convertIBTsToShares(ibts, true);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewWithdrawIBT.txt
maxWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function maxWithdraw

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxWithdraw(address owner) public view override whenNotPaused returns (uint256) {
        return convertToUnderlying(_maxBurnable(owner));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxWithdraw.txt
maxWithdrawIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function maxWithdrawIBT

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxWithdrawIBT(address owner) public view override whenNotPaused returns (uint256) {
        return _convertSharesToIBTs(_maxBurnable(owner), false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxWithdrawIBT.txt
previewRedeem:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewRedeem(uint256 shares) public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(previewRedeemForIBT(shares));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewRedeem.txt
previewRedeemForIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewRedeemForIBT

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewRedeemForIBT(
        uint256 shares
    ) public view override whenNotPaused returns (uint256) {
        return _convertSharesToIBTs(shares, false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewRedeemForIBT.txt
maxRedeem:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxRedeem(address owner) public view override returns (uint256) {
        return _maxBurnable(owner);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxRedeem.txt
totalAssets:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function totalAssets() public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(IERC4626(ibt).balanceOf(address(this)));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-totalAssets.txt
convertToPrincipal:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function convertToPrincipal(uint256 underlyingAmount) external view override returns (uint256) {
        return _convertIBTsToShares(IERC4626(ibt).previewDeposit(underlyingAmount), false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-convertToPrincipal.txt
convertToUnderlying:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function convertToUnderlying(uint256 principalAmount) public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(_convertSharesToIBTs(principalAmount, false));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-convertToUnderlying.txt
underlying:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function underlying() external view override returns (address) {
        return _asset;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-underlying.txt
maturity:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maturity() external view override returns (uint256) {
        return expiry;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maturity.txt
getDuration:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getDuration() external view override returns (uint256) {
        return duration;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getDuration.txt
getIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getIBT() external view override returns (address) {
        return ibt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBT.txt
getYT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getYT() external view override returns (address) {
        return yt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getYT.txt
getIBTRate:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getIBTRate() external view override returns (uint256) {
        (, uint256 _ibtRate) = _getPTandIBTRates(false);
        return _ibtRate;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBTRate.txt
getPTRate:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getPTRate() external view override returns (uint256) {
        (uint256 _ptRate, ) = _getPTandIBTRates(false);
        return _ptRate;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getPTRate.txt
getIBTUnit:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getIBTUnit() external view override returns (uint256) {
        return ibtUnit;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBTUnit.txt
getUnclaimedFeesInIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getUnclaimedFeesInIBT() external view override returns (uint256) {
        return unclaimedFeesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getUnclaimedFeesInIBT.txt
getTotalFeesInIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getTotalFeesInIBT() external view override returns (uint256) {
        return totalFeesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getTotalFeesInIBT.txt
getTokenizationFee:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getTokenizationFee() public view override returns (uint256) {
        return IRegistry(registry).getTokenizationFee();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getTokenizationFee.txt
getCurrentYieldOfUserInIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function getCurrentYieldOfUserInIBT(
        address _user
    ) external view override returns (uint256 _yieldOfUserInIBT) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 _oldIBTRate = ibtRateOfUser[_user];
        uint256 _oldPTRate = ptRateOfUser[_user];
        if (_oldIBTRate != 0) {
            _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
                _user,
                yieldOfUserInIBT[_user],
                _oldIBTRate,
                _ibtRate,
                _oldPTRate,
                _ptRate,
                yt
            );
            _yieldOfUserInIBT -= PrincipalTokenUtil._computeYieldFee(_yieldOfUserInIBT, registry);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getCurrentYieldOfUserInIBT.txt
maxFlashLoan:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxFlashLoan(address _token) public view override returns (uint256) {
        if (_token != ibt) {
            return 0;
        }
        // Entire IBT balance of the contract can be borrowed
        return IERC4626(ibt).balanceOf(address(this));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxFlashLoan.txt
flashFee:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function flashFee(address _token, uint256 _amount) public view override returns (uint256) {
        if (_token != ibt) revert AddressError();
        return PrincipalTokenUtil._computeFlashloanFee(_amount, registry);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-flashFee.txt
flashLoan:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function flashLoan(
        IERC3156FlashBorrower _receiver,
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external override returns (bool) {
        if (_amount > maxFlashLoan(_token)) revert FlashLoanExceedsMaxAmount();

        uint256 fee = flashFee(_token, _amount);
        _updateFees(fee);

        // Initiate the flash loan by lending the requested IBT amount
        IERC20(ibt).safeTransfer(address(_receiver), _amount);

        // Execute the flash loan
        if (_receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) != ON_FLASH_LOAN)
            revert FlashLoanCallbackFailed();

        // Repay the debt + fee
        IERC20(ibt).safeTransferFrom(address(_receiver), address(this), _amount + fee);

        return true;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-flashLoan.txt
name:
symbol:
decimals:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {
        return IERC4626(ibt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-decimals.txt
totalSupply:
balanceOf:
transfer:
allowance:
approve:
transferFrom:
_getPausableStorage:
__Pausable_init:
__Pausable_init_unchained:
paused:
_requireNotPaused:
_requirePaused:
_pause:
_unpause:
__Context_init:
__Context_init_unchained:
_msgSender:
_msgData:
_contextSuffixLength:
_checkInitializing:
_disableInitializers:
_getInitializedVersion:
_isInitializing:
_getInitializableStorage:
_getReentrancyGuardStorage:
__ReentrancyGuard_init:
__ReentrancyGuard_init_unchained:
_nonReentrantBefore:
_nonReentrantAfter:
_reentrancyGuardEntered:
_getAccessManagedStorage:
__AccessManaged_init:
__AccessManaged_init_unchained:
authority:
setAuthority:
isConsumingScheduledOp:
_setAuthority:
_checkCanCall:
authority:
setAuthority:
isConsumingScheduledOp:
__ERC20Permit_init:
__ERC20Permit_init_unchained:
permit:
nonces:
DOMAIN_SEPARATOR:
_getNoncesStorage:
__Nonces_init:
__Nonces_init_unchained:
nonces:
_useNonce:
_useCheckedNonce:
_getEIP712Storage:
__EIP712_init:
__EIP712_init_unchained:
_domainSeparatorV4:
_buildDomainSeparator:
_hashTypedDataV4:
eip712Domain:
_EIP712Name:
_EIP712Version:
_EIP712NameHash:
_EIP712VersionHash:
eip712Domain:
permit:
nonces:
DOMAIN_SEPARATOR:
_getERC20Storage:
__ERC20_init:
__ERC20_init_unchained:
name:
symbol:
decimals:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {
        return IERC4626(ibt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-decimals.txt
totalSupply:
balanceOf:
transfer:
allowance:
approve:
transferFrom:
_transfer:
_update:
_mint:
_burn:
_approve:
_approve:
_spendAllowance:
constructor:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:registry
    constructor(address _registry) {
        if (_registry == address(0)) {
            revert AddressError();
        }
        registry = _registry;
        _disableInitializers(); // using this so that the deployed logic contract cannot later be initialized
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-constructor.txt
initialize:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function initialize
MAX_DECIMALS, MIN_DECIMALS, _asset, _assetDecimals, _ibtDecimals, expiry, ibt, ibtUnit
there may be a problem : Comparison statement order adjustment in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : Comparison statement order adjustment in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : check before updating state variable with same value in initialize
there may be a problem : Comparison statement order adjustment in initialize
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in initialize
['2.2', '2.4', '3.6', '2.7', '2.11', '1.1', '3.2', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    4.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    5.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    6.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    7.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    8.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:MAX_DECIMALS, MIN_DECIMALS, _asset, _assetDecimals, _ibtDecimals, expiry, ibt, ibtUnit
function state variables written:_asset, _assetDecimals, _ibtDecimals, duration, expiry, ibt, ibtRate, ibtUnit, ptRate, yt
    function initialize(
        address _ibt,
        uint256 _duration,
        address _initialAuthority
    ) external initializer {
        if (_ibt == address(0) || _initialAuthority == address(0)) {
            revert AddressError();
        }
        if (IERC4626(_ibt).totalAssets() == 0) {
            revert RateError();
        }
        _asset = IERC4626(_ibt).asset();
        duration = _duration;
        expiry = _duration + block.timestamp;
        string memory _ibtSymbol = IERC4626(_ibt).symbol();
        string memory name = NamingUtil.genPTName(_ibtSymbol, expiry);
        __ERC20_init(name, NamingUtil.genPTSymbol(_ibtSymbol, expiry));
        __ERC20Permit_init(name);
        __Pausable_init();
        __ReentrancyGuard_init();
        __AccessManaged_init(_initialAuthority);
        _ibtDecimals = IERC4626(_ibt).decimals();
        _assetDecimals = PrincipalTokenUtil._tryGetTokenDecimals(_asset);
        if (
            _assetDecimals < MIN_DECIMALS ||
            _assetDecimals > _ibtDecimals ||
            _ibtDecimals > MAX_DECIMALS
        ) {
            revert InvalidDecimals();
        }
        ibt = _ibt;
        ibtUnit = 10 ** _ibtDecimals;
        ibtRate = IERC4626(ibt).previewRedeem(ibtUnit).toRay(_assetDecimals);
        ptRate = RayMath.RAY_UNIT;
        yt = _deployYT(
            NamingUtil.genYTName(_ibtSymbol, expiry),
            NamingUtil.genYTSymbol(_ibtSymbol, expiry)
        );
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-initialize.txt
pause:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function pause

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function pause() external override restricted {
        _pause();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-pause.txt
unPause:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function unPause

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function unPause() external override restricted {
        _unpause();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-unPause.txt
deposit:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
deposit:
_asset, ibt
there may be a problem : Do not declare local variables used only once in deposit
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in deposit
['2.2', '2.4', '2.11', '3.2', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:ibts
function state variables read:_asset, ibt
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
deposit:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function deposit(uint256 assets, address receiver) external override returns (uint256 shares) {
        shares = deposit(assets, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-deposit.txt
depositIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
depositIBT:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
depositIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function depositIBT(uint256 ibts, address receiver) external override returns (uint256 shares) {
        shares = depositIBT(ibts, receiver, receiver);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-depositIBT.txt
redeem:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 assets) {
        _beforeRedeem(shares, owner);
        assets = IERC4626(ibt).redeem(_convertSharesToIBTs(shares, false), receiver, address(this));
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeem.txt
redeem:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeem(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 assets) {
        _beforeRedeem(shares, owner);
        assets = IERC4626(ibt).redeem(_convertSharesToIBTs(shares, false), receiver, address(this));
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeem.txt
redeemForIBT:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function redeemForIBT(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 ibts) {
        _beforeRedeem(shares, owner);
        ibts = _convertSharesToIBTs(shares, false);
        IERC20(ibt).safeTransfer(receiver, ibts);
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeemForIBT.txt
redeemForIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function redeemForIBT(
        uint256 shares,
        address receiver,
        address owner
    ) public override returns (uint256 ibts) {
        _beforeRedeem(shares, owner);
        ibts = _convertSharesToIBTs(shares, false);
        IERC20(ibt).safeTransfer(receiver, ibts);
        emit Redeem(owner, receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-redeemForIBT.txt
withdraw:
ibt
there may be a problem : Do not declare local variables used only once in withdraw
['2.2', '2.4', '2.11', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:_ptRate, _ibtRate, ibts
function state variables read:ibt
function state variables written:
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(assets, owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 ibts = IERC4626(ibt).withdraw(assets, receiver, address(this));
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdraw.txt
withdraw:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdraw(
        uint256 assets,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(assets, owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 ibts = IERC4626(ibt).withdraw(assets, receiver, address(this));
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdraw.txt
withdrawIBT:
ibt
there may be a problem : Do not declare local variables used only once in withdrawIBT
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in withdrawIBT
['2.2', '2.4', '2.11', '3.2', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:_ptRate, _ibtRate
function state variables read:ibt
function state variables written:
    function withdrawIBT(
        uint256 ibts,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(IERC4626(ibt).previewRedeem(ibts), owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
        // send IBTs from this contract to receiver
        IERC20(ibt).safeTransfer(receiver, ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdrawIBT.txt
withdrawIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function withdrawIBT(
        uint256 ibts,
        address receiver,
        address owner
    ) public override returns (uint256 shares) {
        _beforeWithdraw(IERC4626(ibt).previewRedeem(ibts), owner);
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        shares = _withdrawShares(ibts, receiver, owner, _ptRate, _ibtRate);
        // send IBTs from this contract to receiver
        IERC20(ibt).safeTransfer(receiver, ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-withdrawIBT.txt
claimFees:
ibt, registry, unclaimedFeesInIBT
there may be a problem : check before updating state variable with same value in claimFees
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in claimFees
['2.2', '2.4', '3.6', '2.11', '3.2', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt, registry, unclaimedFeesInIBT
function state variables written:unclaimedFeesInIBT
    function claimFees() external override returns (uint256 assets) {
        if (msg.sender != IRegistry(registry).getFeeCollector()) {
            revert UnauthorizedCaller();
        }
        uint256 ibts = unclaimedFeesInIBT;
        unclaimedFeesInIBT = 0;
        assets = IERC4626(ibt).redeem(ibts, msg.sender, address(this));
        emit FeeClaimed(msg.sender, ibts, assets);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimFees.txt
updateYield:
ibtRateOfUser, ptRateOfUser, yieldOfUserInIBT, yt
there may be a problem : Comparison statement order adjustment in updateYield
there may be a problem : check before updating state variable with same value in updateYield
there may be a problem : check before updating state variable with same value in updateYield
there may be a problem : check before updating state variable with same value in updateYield
there may be a problem : Comparison statement order adjustment in updateYield
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in updateYield
['2.2', '2.4', '3.6', '2.7', '2.11', '3.2', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    4.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    5.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    6.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    7.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibtRateOfUser, ptRateOfUser, yieldOfUserInIBT, yt
function state variables written:ibtRateOfUser, ptRateOfUser, yieldOfUserInIBT
    function updateYield(address _user) public override returns (uint256 updatedUserYieldInIBT) {
        (uint256 _ptRate, uint256 _ibtRate) = _updatePTandIBTRates();

        uint256 _oldIBTRateUser = ibtRateOfUser[_user];
        if (_oldIBTRateUser != _ibtRate) {
            ibtRateOfUser[_user] = _ibtRate;
        }
        uint256 _oldPTRateUser = ptRateOfUser[_user];
        if (_oldPTRateUser != _ptRate) {
            ptRateOfUser[_user] = _ptRate;
        }

        // Check for skipping yield update when the user deposits for the first time or rates decreased to 0.
        if (_oldIBTRateUser != 0) {
            updatedUserYieldInIBT = PrincipalTokenUtil._computeYield(
                _user,
                yieldOfUserInIBT[_user],
                _oldIBTRateUser,
                _ibtRate,
                _oldPTRateUser,
                _ptRate,
                yt
            );
            yieldOfUserInIBT[_user] = updatedUserYieldInIBT;
            emit YieldUpdated(_user, updatedUserYieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-updateYield.txt
claimYield:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function claimYield(address _receiver) public override returns (uint256 yieldInAsset) {
        uint256 yieldInIBT = _claimYield();
        if (yieldInIBT != 0) {
            yieldInAsset = IERC4626(ibt).redeem(yieldInIBT, _receiver, address(this));
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimYield.txt
claimYieldInIBT:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function claimYieldInIBT(address _receiver) public override returns (uint256 yieldInIBT) {
        yieldInIBT = _claimYield();
        if (yieldInIBT != 0) {
            IERC20(ibt).safeTransfer(_receiver, yieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimYieldInIBT.txt
beforeYtTransfer:
yt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:yt
function state variables written:
    function beforeYtTransfer(address _from, address _to) external override {
        if (msg.sender != yt) {
            revert UnauthorizedCaller();
        }
        updateYield(_from);
        updateYield(_to);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-beforeYtTransfer.txt
claimRewards:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function claimRewards
rewardsProxy
there may be a problem : Comparison statement order adjustment in claimRewards
there may be a problem : Do not declare local variables used only once in claimRewards
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in claimRewards
['2.2', '2.4', '2.7', '2.11', '1.1', '3.2', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    6.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    7.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    8.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:success
function state variables read:rewardsProxy
function state variables written:
    function claimRewards(bytes memory _data) external restricted {
        if (rewardsProxy == address(0)) {
            revert NoRewardsProxySet();
        }
        _data = abi.encodeWithSelector(IRewardsProxy(rewardsProxy).claimRewards.selector, _data);
        (bool success, ) = rewardsProxy.delegatecall(_data);
        if (!success) {
            revert ClaimRewardsFailed();
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-claimRewards.txt
storeRatesAtExpiry:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function storeRatesAtExpiry
ibtRate, ptRate, ratesAtExpiryStored
there may be a problem : check before updating state variable with same value in storeRatesAtExpiry
there may be a problem : check before updating state variable with same value in storeRatesAtExpiry
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in storeRatesAtExpiry
['2.2', '2.4', '3.6', '2.11', '1.1', '3.2', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    6.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    7.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibtRate, ptRate, ratesAtExpiryStored
function state variables written:ibtRate, ptRate, ratesAtExpiryStored
    function storeRatesAtExpiry() public override afterExpiry {
        if (ratesAtExpiryStored) {
            revert RatesAtExpiryAlreadyStored();
        }
        ratesAtExpiryStored = true;
        // PT rate not rounded up here
        (ptRate, ibtRate) = _getCurrentPTandIBTRates(false);
        emit RatesStoredAtExpiry(ibtRate, ptRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-storeRatesAtExpiry.txt
setRewardsProxy:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function setRewardsProxy
rewardsProxy
there may be a problem : check before updating state variable with same value in setRewardsProxy
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in setRewardsProxy
['2.2', '2.4', '3.6', '2.11', '1.1', '3.2', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    6.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    7.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:rewardsProxy
function state variables written:rewardsProxy
    function setRewardsProxy(address _rewardsProxy) external restricted {
        // Note: address zero is allowed in order to disable the claim proxy
        emit RewardsProxyChange(rewardsProxy, _rewardsProxy);
        rewardsProxy = _rewardsProxy;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-setRewardsProxy.txt
previewDeposit:
ibt
there may be a problem : Do not declare local variables used only once in previewDeposit
['2.2', '2.4', '2.11', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:ibts
function state variables read:ibt
function state variables written:
    function previewDeposit(uint256 assets) public view override returns (uint256) {
        uint256 ibts = IERC4626(ibt).previewDeposit(assets);
        return _previewDepositIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewDeposit.txt
previewDepositIBT:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewDepositIBT(uint256 ibts) external view override returns (uint256) {
        return _previewDepositIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewDepositIBT.txt
maxDeposit:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxDeposit(address) external pure override returns (uint256) {
        return type(uint256).max;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxDeposit.txt
previewWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewWithdraw
ibt
there may be a problem : Do not declare local variables used only once in previewWithdraw
['2.2', '2.4', '2.11', '1.1', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:ibts
function state variables read:ibt
function state variables written:
    function previewWithdraw(
        uint256 assets
    ) external view override whenNotPaused returns (uint256) {
        uint256 ibts = IERC4626(ibt).previewWithdraw(assets);
        return previewWithdrawIBT(ibts);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewWithdraw.txt
previewWithdrawIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewWithdrawIBT

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewWithdrawIBT(uint256 ibts) public view override whenNotPaused returns (uint256) {
        return _convertIBTsToShares(ibts, true);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewWithdrawIBT.txt
maxWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function maxWithdraw

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxWithdraw(address owner) public view override whenNotPaused returns (uint256) {
        return convertToUnderlying(_maxBurnable(owner));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxWithdraw.txt
maxWithdrawIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function maxWithdrawIBT

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxWithdrawIBT(address owner) public view override whenNotPaused returns (uint256) {
        return _convertSharesToIBTs(_maxBurnable(owner), false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxWithdrawIBT.txt
previewRedeem:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function previewRedeem(uint256 shares) public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(previewRedeemForIBT(shares));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewRedeem.txt
previewRedeemForIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function previewRedeemForIBT

['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function previewRedeemForIBT(
        uint256 shares
    ) public view override whenNotPaused returns (uint256) {
        return _convertSharesToIBTs(shares, false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-previewRedeemForIBT.txt
maxRedeem:

['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function maxRedeem(address owner) public view override returns (uint256) {
        return _maxBurnable(owner);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxRedeem.txt
convertToPrincipal:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function convertToPrincipal(uint256 underlyingAmount) external view override returns (uint256) {
        return _convertIBTsToShares(IERC4626(ibt).previewDeposit(underlyingAmount), false);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-convertToPrincipal.txt
convertToUnderlying:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function convertToUnderlying(uint256 principalAmount) public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(_convertSharesToIBTs(principalAmount, false));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-convertToUnderlying.txt
totalAssets:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function totalAssets() public view override returns (uint256) {
        return IERC4626(ibt).previewRedeem(IERC4626(ibt).balanceOf(address(this)));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-totalAssets.txt
decimals:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function decimals() public view override(IERC20Metadata, ERC20Upgradeable) returns (uint8) {
        return IERC4626(ibt).decimals();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-decimals.txt
underlying:
_asset
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:_asset
function state variables written:
    function underlying() external view override returns (address) {
        return _asset;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-underlying.txt
maturity:
expiry
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:expiry
function state variables written:
    function maturity() external view override returns (uint256) {
        return expiry;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maturity.txt
getDuration:
duration
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:duration
function state variables written:
    function getDuration() external view override returns (uint256) {
        return duration;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getDuration.txt
getIBT:
ibt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function getIBT() external view override returns (address) {
        return ibt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBT.txt
getYT:
yt
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:yt
function state variables written:
    function getYT() external view override returns (address) {
        return yt;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getYT.txt
getIBTRate:

there may be a problem : Do not declare local variables used only once in getIBTRate
['2.2', '2.4', '2.11', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:_ibtRate
function state variables read:
function state variables written:
    function getIBTRate() external view override returns (uint256) {
        (, uint256 _ibtRate) = _getPTandIBTRates(false);
        return _ibtRate;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBTRate.txt
getPTRate:

there may be a problem : Do not declare local variables used only once in getPTRate
['2.2', '2.4', '2.11', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:_ptRate
function state variables read:
function state variables written:
    function getPTRate() external view override returns (uint256) {
        (uint256 _ptRate, ) = _getPTandIBTRates(false);
        return _ptRate;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getPTRate.txt
getIBTUnit:
ibtUnit
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibtUnit
function state variables written:
    function getIBTUnit() external view override returns (uint256) {
        return ibtUnit;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getIBTUnit.txt
getUnclaimedFeesInIBT:
unclaimedFeesInIBT
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:unclaimedFeesInIBT
function state variables written:
    function getUnclaimedFeesInIBT() external view override returns (uint256) {
        return unclaimedFeesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getUnclaimedFeesInIBT.txt
getTotalFeesInIBT:
totalFeesInIBT
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:totalFeesInIBT
function state variables written:
    function getTotalFeesInIBT() external view override returns (uint256) {
        return totalFeesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getTotalFeesInIBT.txt
getCurrentYieldOfUserInIBT:
ibtRateOfUser, ptRateOfUser, registry, yieldOfUserInIBT, yt
there may be a problem : Comparison statement order adjustment in getCurrentYieldOfUserInIBT
there may be a problem : Comparison statement order adjustment in getCurrentYieldOfUserInIBT
there may be a problem : Comparison statement order adjustment in getCurrentYieldOfUserInIBT
there may be a problem : ++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1) in function getCurrentYieldOfUserInIBT
there may be a problem : Do not declare local variables used only once in getCurrentYieldOfUserInIBT
['2.2', '2.4', '2.7', '2.3', '2.11', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1)
You find that unsigned int increases or decreases, and you can change i++ and i+=1 into ++i, i-- the same thing. While, there will be some situations you don't need to change. For example, a = i++; or a = functionA(i++);.
    5.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    6.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    7.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:_ptRate, _ibtRate, _oldPTRate
function state variables read:ibtRateOfUser, ptRateOfUser, registry, yieldOfUserInIBT, yt
function state variables written:
    function getCurrentYieldOfUserInIBT(
        address _user
    ) external view override returns (uint256 _yieldOfUserInIBT) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        uint256 _oldIBTRate = ibtRateOfUser[_user];
        uint256 _oldPTRate = ptRateOfUser[_user];
        if (_oldIBTRate != 0) {
            _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
                _user,
                yieldOfUserInIBT[_user],
                _oldIBTRate,
                _ibtRate,
                _oldPTRate,
                _ptRate,
                yt
            );
            _yieldOfUserInIBT -= PrincipalTokenUtil._computeYieldFee(_yieldOfUserInIBT, registry);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getCurrentYieldOfUserInIBT.txt
maxFlashLoan:
ibt
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in maxFlashLoan
['2.2', '2.4', '2.11', '3.2', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ibt
function state variables written:
    function maxFlashLoan(address _token) public view override returns (uint256) {
        if (_token != ibt) {
            return 0;
        }
        // Entire IBT balance of the contract can be borrowed
        return IERC4626(ibt).balanceOf(address(this));
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-maxFlashLoan.txt
flashFee:
ibt, registry
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibt, registry
function state variables written:
    function flashFee(address _token, uint256 _amount) public view override returns (uint256) {
        if (_token != ibt) revert AddressError();
        return PrincipalTokenUtil._computeFlashloanFee(_amount, registry);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-flashFee.txt
getTokenizationFee:
registry
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:registry
function state variables written:
    function getTokenizationFee() public view override returns (uint256) {
        return IRegistry(registry).getTokenizationFee();
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-getTokenizationFee.txt
flashLoan:
ON_FLASH_LOAN, ibt
there may be a problem : Comparison statement order adjustment in flashLoan
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in flashLoan
['2.2', '2.4', '2.7', '2.11', '3.2', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:ON_FLASH_LOAN, ibt
function state variables written:
    function flashLoan(
        IERC3156FlashBorrower _receiver,
        address _token,
        uint256 _amount,
        bytes calldata _data
    ) external override returns (bool) {
        if (_amount > maxFlashLoan(_token)) revert FlashLoanExceedsMaxAmount();

        uint256 fee = flashFee(_token, _amount);
        _updateFees(fee);

        // Initiate the flash loan by lending the requested IBT amount
        IERC20(ibt).safeTransfer(address(_receiver), _amount);

        // Execute the flash loan
        if (_receiver.onFlashLoan(msg.sender, _token, _amount, fee, _data) != ON_FLASH_LOAN)
            revert FlashLoanCallbackFailed();

        // Repay the debt + fee
        IERC20(ibt).safeTransferFrom(address(_receiver), address(this), _amount + fee);

        return true;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-flashLoan.txt
_previewDepositIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function _previewDepositIBT
registry
there may be a problem : Do not declare local variables used only once in _previewDepositIBT
['2.2', '2.4', '2.11', '1.1', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:tokenizationFee
function state variables read:registry
function state variables written:
    function _previewDepositIBT(
        uint256 _ibts
    ) internal view notExpired whenNotPaused returns (uint256) {
        uint256 tokenizationFee = PrincipalTokenUtil._computeTokenizationFee(
            _ibts,
            address(this),
            registry
        );

        return _convertIBTsToSharesPreview(_ibts - tokenizationFee);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_previewDepositIBT.txt
_convertSharesToIBTs:

there may be a problem : Comparison statement order adjustment in _convertSharesToIBTs
there may be a problem : Comparison statement order adjustment in _convertSharesToIBTs
there may be a problem : Comparison statement order adjustment in _convertSharesToIBTs
['2.2', '2.4', '2.7', '2.11', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function _convertSharesToIBTs(
        uint256 _shares,
        bool _roundUp
    ) internal view returns (uint256 ibts) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        if (_ibtRate == 0) {
            revert RateError();
        }
        ibts = _shares.mulDiv(
            _ptRate,
            _ibtRate,
            _roundUp ? Math.Rounding.Ceil : Math.Rounding.Floor
        );
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_convertSharesToIBTs.txt
_convertIBTsToShares:

there may be a problem : Comparison statement order adjustment in _convertIBTsToShares
there may be a problem : Comparison statement order adjustment in _convertIBTsToShares
there may be a problem : Comparison statement order adjustment in _convertIBTsToShares
['2.2', '2.4', '2.7', '2.11', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:
function state variables written:
    function _convertIBTsToShares(
        uint256 _ibts,
        bool _roundUp
    ) internal view returns (uint256 shares) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        if (_ptRate == 0) {
            revert RateError();
        }
        shares = _ibts.mulDiv(
            _ibtRate,
            _ptRate,
            _roundUp ? Math.Rounding.Ceil : Math.Rounding.Floor
        );
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_convertIBTsToShares.txt
_convertIBTsToSharesPreview:

there may be a problem : Comparison statement order adjustment in _convertIBTsToSharesPreview
there may be a problem : Do not declare local variables used only once in _convertIBTsToSharesPreview
['2.2', '2.4', '2.7', '2.11', '3.5', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.Do not declare local variables used only once.
You should first check all the local variables decleared in the code, for every variable, you must consider whether it's used in a loop.If its used in a loop or loop condition check, make no change. if it's not used in aloop and it used only once, you should avoid it.
    example:
-        UniTwapPoolInfo memory uniTwapPoolInfoStruct = uniTwapPoolInfo[                          
-            _tokenAddress                                                                        
-        ];                                                                                       
-                                                                                                 
-        if (uniTwapPoolInfoStruct.oracle > ZERO_ADDRESS) {                                       
+        if (uniTwapPoolInfo[_tokenAddress].oracle > ZERO_ADDRESS) {                              
             revert AggregatorNotNecessary();                                                     
         } 
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
variable used once:_ibtRate
function state variables read:
function state variables written:
    function _convertIBTsToSharesPreview(uint256 ibts) internal view returns (uint256 shares) {
        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(true); // to round up the shares, the PT rate must round down
        if (_ptRate == 0) {
            revert RateError();
        }
        shares = ibts.mulDiv(_ibtRate, _ptRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_convertIBTsToSharesPreview.txt
_updateFees:
totalFeesInIBT, unclaimedFeesInIBT
there may be a problem : ++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1) in function _updateFees
there may be a problem : a = a + b is more gas effective than a += b for state variables in _updateFees
there may be a problem : check before updating state variable with same value in _updateFees
there may be a problem : ++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1) in function _updateFees
there may be a problem : a = a + b is more gas effective than a += b for state variables in _updateFees
there may be a problem : check before updating state variable with same value in _updateFees
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in _updateFees
['2.2', '2.4', '3.6', '2.3', '2.11', '3.2', '2.8', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    4.++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1)
You find that unsigned int increases or decreases, and you can change i++ and i+=1 into ++i, i-- the same thing. While, there will be some situations you don't need to change. For example, a = i++; or a = functionA(i++);.
    5.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    6.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    7.a = a + b is more gas effective than a += b for state variables(excluding mapping and arrays)
You first need to determine where the state variable(not an array or mapping) is written in the code, and when the state variable executes a+=b statement, you need to change it to a=a+b statement to save gas.
    8.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:totalFeesInIBT, unclaimedFeesInIBT
function state variables written:totalFeesInIBT, unclaimedFeesInIBT
    function _updateFees(uint256 _feesInIBT) internal {
        unclaimedFeesInIBT += _feesInIBT;
        totalFeesInIBT += _feesInIBT;
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_updateFees.txt
_deployYT:
there may be a problem : Avoid declaring unused variables or unused internal function in function _deployYT
registry
there may be a problem : Use calldata instead of memory for function arguments that do not get mutated in _deployYT
['2.2', '2.4', '2.11', '4.1', '3.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    5.Use calldata instead of memory for function arguments that do not get mutated
You should first find function arguments that do not need to be changed within the function. If its type is memory, you mark the data type as calldata. But its type is not memory(such as byte32 or address), skip it.
    
solidity version :0.8.20
function state variables read:registry
function state variables written:
    function _deployYT(string memory _name, string memory _symbol) internal returns (address _yt) {
        address ytBeacon = IRegistry(registry).getYTBeacon();
        if (ytBeacon == address(0)) {
            revert BeaconNotSet();
        }
        _yt = address(
            new BeaconProxy(
                ytBeacon,
                abi.encodeWithSelector(
                    IYieldToken(address(0)).initialize.selector,
                    _name,
                    _symbol,
                    address(this)
                )
            )
        );
        emit YTDeployed(_yt);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_deployYT.txt
_depositIBT:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function _depositIBT
registry, yt
['2.2', '2.4', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    4.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:registry, yt
function state variables written:
    function _depositIBT(
        uint256 _ibts,
        address _ptReceiver,
        address _ytReceiver
    ) internal notExpired nonReentrant whenNotPaused returns (uint256 shares) {
        updateYield(_ytReceiver);
        uint256 tokenizationFee = PrincipalTokenUtil._computeTokenizationFee(
            _ibts,
            address(this),
            registry
        );
        _updateFees(tokenizationFee);
        shares = _convertIBTsToShares(_ibts - tokenizationFee, false);
        if (shares == 0) {
            revert RateError();
        }
        _mint(_ptReceiver, shares);
        emit Mint(msg.sender, _ptReceiver, shares);
        IYieldToken(yt).mint(_ytReceiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_depositIBT.txt
_withdrawShares:
there may be a problem : Avoid declaring unused variables or unused internal function in function _withdrawShares
expiry, yt
there may be a problem : Comparison statement order adjustment in _withdrawShares
['2.2', '2.4', '2.7', '2.11', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:expiry, yt
function state variables written:
    function _withdrawShares(
        uint256 _ibts,
        address _receiver,
        address _owner,
        uint256 _ptRate,
        uint256 _ibtRate
    ) internal returns (uint256 shares) {
        if (_ptRate == 0) {
            revert RateError();
        }
        // convert ibts to shares using provided rates
        shares = _ibts.mulDiv(_ibtRate, _ptRate, Math.Rounding.Ceil);
        // burn owner's shares (YT and PT)
        if (block.timestamp < expiry) {
            IYieldToken(yt).burnWithoutUpdate(_owner, shares);
        }
        _burn(_owner, shares);
        emit Redeem(_owner, _receiver, shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_withdrawShares.txt
_beforeRedeem:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function _beforeRedeem
expiry, ratesAtExpiryStored, yt
there may be a problem : Comparison statement order adjustment in _beforeRedeem
['2.2', '2.4', '2.7', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:expiry, ratesAtExpiryStored, yt
function state variables written:
    function _beforeRedeem(uint256 _shares, address _owner) internal nonReentrant whenNotPaused {
        if (_owner != msg.sender) {
            revert UnauthorizedCaller();
        }
        if (_shares > _maxBurnable(_owner)) {
            revert UnsufficientBalance();
        }
        if (block.timestamp >= expiry) {
            if (!ratesAtExpiryStored) {
                storeRatesAtExpiry();
            }
        } else {
            updateYield(_owner);
            IYieldToken(yt).burnWithoutUpdate(_owner, _shares);
        }
        _burn(_owner, _shares);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_beforeRedeem.txt
_beforeWithdraw:
there may be a problem : functions guaranteed to revert when called by normal users can be marked payable in function _beforeWithdraw
expiry, ratesAtExpiryStored
there may be a problem : Comparison statement order adjustment in _beforeWithdraw
['2.2', '2.4', '2.7', '2.11', '1.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.functions guaranteed to revert when called by normal users can be marked payable.
You note that marking a function as payable should only be done when the function is expected to receive funds. However, it's crucial to thoroughly analyze the security implications and ensure that the payable modifier is used appropriately.
    example:
        modifier onlyOwner() {
            require(msg.sender == owner, "Not the owner");
            _;
        }

        // Function guaranteed to revert when called by normal users
-        function someFunction() external onlyOwner {
+        function someFunction() external payable onlyOwner {
            // Function logic here
        }
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:expiry, ratesAtExpiryStored
function state variables written:
    function _beforeWithdraw(uint256 _assets, address _owner) internal whenNotPaused nonReentrant {
        if (_owner != msg.sender) {
            revert UnauthorizedCaller();
        }
        if (block.timestamp >= expiry) {
            if (!ratesAtExpiryStored) {
                storeRatesAtExpiry();
            }
        } else {
            updateYield(_owner);
        }
        if (maxWithdraw(_owner) < _assets) {
            revert UnsufficientBalance();
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_beforeWithdraw.txt
_claimYield:
registry
there may be a problem : check before updating state variable with same value in _claimYield
there may be a problem : ++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1) in function _claimYield
['2.2', '2.4', '3.6', '2.3', '2.11', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    4.++i costs less gas compared to i++ or i += 1 (same for --i vs i-- or i -= 1)
You find that unsigned int increases or decreases, and you can change i++ and i+=1 into ++i, i-- the same thing. While, there will be some situations you don't need to change. For example, a = i++; or a = functionA(i++);.
    5.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    6.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:registry
function state variables written:yieldOfUserInIBT
    function _claimYield() internal returns (uint256 yieldInIBT) {
        yieldInIBT = updateYield(msg.sender);
        if (yieldInIBT == 0) {
            return 0;
        } else {
            yieldOfUserInIBT[msg.sender] = 0;
            uint256 yieldFeeInIBT = PrincipalTokenUtil._computeYieldFee(yieldInIBT, registry);
            _updateFees(yieldFeeInIBT);
            yieldInIBT -= yieldFeeInIBT;
            emit YieldClaimed(msg.sender, msg.sender, yieldInIBT);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_claimYield.txt
_maxBurnable:
expiry, yt
there may be a problem : Comparison statement order adjustment in _maxBurnable
['2.2', '2.4', '2.7', '2.11', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:expiry, yt
function state variables written:
    function _maxBurnable(address _user) internal view returns (uint256 maxBurnable) {
        if (block.timestamp >= expiry) {
            maxBurnable = balanceOf(_user);
        } else {
            uint256 ptBalance = balanceOf(_user);
            uint256 ytBalance = IYieldToken(yt).balanceOf(_user);
            maxBurnable = (ptBalance > ytBalance) ? ytBalance : ptBalance;
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_maxBurnable.txt
_updatePTandIBTRates:
expiry, ibtRate, ptRate, ratesAtExpiryStored
there may be a problem : check before updating state variable with same value in _updatePTandIBTRates
there may be a problem : check before updating state variable with same value in _updatePTandIBTRates
there may be a problem : Comparison statement order adjustment in _updatePTandIBTRates
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in _updatePTandIBTRates
['2.2', '2.4', '3.6', '2.7', '2.11', '3.2', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.check before updating state variable with same value.
You should first look for where to write the state variable, and then determine whether it is an assignment statement. If it is a self-incresement(decresement) statement, make no change.If it is set in a constructor or initializer function, make no change. if it is an assignment statement,but not in the form a=a+b, you need to check before updating state variable with same value.
    example:
    function setApprovalForAll(address operator, bool approved) public {
+        if (isApprovedForAll[msg.sender][operator] == approved) return;
        isApprovedForAll[msg.sender][operator] = approved;
        emit ApprovalForAll(msg.sender, operator, approved);
    }
    4.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    5.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    6.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    7.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:expiry, ibtRate, ptRate, ratesAtExpiryStored
function state variables written:ibtRate, ptRate
    function _updatePTandIBTRates() internal returns (uint256 _ptRate, uint256 _ibtRate) {
        if (block.timestamp >= expiry) {
            if (!ratesAtExpiryStored) {
                storeRatesAtExpiry();
            }
        }
        (_ptRate, _ibtRate) = _getPTandIBTRates(false);
        if (block.timestamp < expiry) {
            if (_ibtRate != ibtRate) {
                ibtRate = _ibtRate;
            }
            if (_ptRate != ptRate) {
                ptRate = _ptRate;
            }
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_updatePTandIBTRates.txt
_getCurrentPTandIBTRates:
_assetDecimals, ibt, ibtRate, ibtUnit, ptRate
there may be a problem : Splitting require() statements that use && saves gas in _getCurrentPTandIBTRates
there may be a problem : Comparison statement order adjustment in _getCurrentPTandIBTRates
there may be a problem : Comparison statement order adjustment in _getCurrentPTandIBTRates
there may be a problem : Comparison statement order adjustment in _getCurrentPTandIBTRates
there may be a problem : Comparison statement order adjustment in _getCurrentPTandIBTRates
there may be a problem : state variables should be cached in stack variables rather than re-reading them from storage in _getCurrentPTandIBTRates
['2.2', '2.4', '2.7', '2.11', '3.2', '2.1', '4.1']
    1.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    2.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    3.Comparison statement order adjustment.
You should first look for multiple conditional statements in the code, and then try to move the cheaper check or the early exit function check to the front.
    example1:
    function _isValidSafeOwner(address owner, address safe) internal view {
-        // Make sure only protocol-deployed safes can rent.
-        if (STORE.deployedSafes(safe) == 0) {
-            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
-        }
         // Make sure the fulfiller is the owner of the recipient rental safe.
         if (!ISafe(safe).isOwner(owner)) {
             revert Errors.CreatePolicy_InvalidSafeOwner(owner, safe);
         }
+
+        // Make sure only protocol-deployed safes can rent.
+        if (STORE.deployedSafes(safe) == 0) {
+            revert Errors.CreatePolicy_InvalidRentalSafe(safe);
+        }
    example2:
-    return (_nonce < getMinNonce(_address) || nonceValues[addressAsKey][_nonce] > 0);
+    return (nonceValues[addressAsKey][_nonce] > 0 || _nonce < getMinNonce(_address));
    example3:
-    (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
    uint256 _oldIBTRate = ibtRateOfUser[_user];
-    uint256 _oldPTRate = ptRateOfUser[_user];
    if (_oldIBTRate != 0) {       
+        uint256 _oldPTRate = ptRateOfUser[_user];
+        (uint256 _ptRate, uint256 _ibtRate) = _getPTandIBTRates(false);
        _yieldOfUserInIBT = PrincipalTokenUtil._computeYield(
            _user,
            yieldOfUserInIBT[_user],
            _oldIBTRate,
            _ibtRate,
            _oldPTRate,
            _ptRate,
            yt
        );
    4.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    5.state variables should be cached in stack variables rather than re-reading them from storage
You should first look for the location of the state variable in the function. Attention here, for every variable, in the function the variable is written in, don't cache the state variable. On other case, you can consider set it as a local variable.
    example:
    uint256 a;
    function somefunction() public {
-        uint256 x = a;
-        uint256 y = a + 1;
+        uint256 tmp = a;
+        uint256 x = tmp;
+        uint256 y = tmp + 1;
        return x + y;
    }
    6.Splitting require() statements that use && saves gas.
When you find that the require statement's judgement has a continuous judgement of &&, you can split it into multiple require statements to save gas.
    example:
-    require(amount > 0 && amount <= getMaxTransactionAmount() && isTransactionAllowed(), "Invalid transaction");
+    require(amount > 0, "Invalid transaction");
+    require(amount <= getMaxTransactionAmount(), "Invalid transaction");
+    require(isTransactionAllowed(), "Invalid transaction");
    7.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    
solidity version :0.8.20
function state variables read:_assetDecimals, ibt, ibtRate, ibtUnit, ptRate
function state variables written:
    function _getCurrentPTandIBTRates(bool roundUpPTRate) internal view returns (uint256, uint256) {
        uint256 currentIBTRate = IERC4626(ibt).previewRedeem(ibtUnit).toRay(_assetDecimals);
        if (IERC4626(ibt).totalAssets() == 0 && IERC4626(ibt).totalSupply() != 0) {
            currentIBTRate = 0;
        }
        uint256 currentPTRate = currentIBTRate < ibtRate
            ? ptRate.mulDiv(
                currentIBTRate,
                ibtRate,
                roundUpPTRate ? Math.Rounding.Ceil : Math.Rounding.Floor
            )
            : ptRate;
        return (currentPTRate, currentIBTRate);
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_getCurrentPTandIBTRates.txt
_getPTandIBTRates:
ibtRate, ptRate, ratesAtExpiryStored
['2.11', '2.2', '4.1', '2.4']
    1.Repetitive code optimization
You first need to find similar statements in the function, and then try to combine them with simpler statements or loop statements.
    2.Using unchecked blocks to save gas
If we know that our mathematics will be safe we could safe a little gas by using unchecked.
    example:
    function calculateSumAndProduct(uint256 n, uint256 multiplier) external pure returns (uint256 sum, uint256 product) {
        require(n < 2**128, "n is too large"); // Ensures n won't cause overflow
        require(multiplier < 2**128, "Multiplier is too large"); // Validates multiplier is safe
        sum = 0;
        product = 1;
        unchecked {
            for (uint256 i = 1; i <= n; i++) {
                sum += i; // Loop has a natural upper bound (n), no overflow risk
                product *= multiplier; // Pre-sanitized multiplier ensures safety
            }
        }
    }
    if (_oldPTRate == _ptRate && _ibtRate > _oldIBTRate) {
-        newYieldInIBTRay = ibtOfPTInRay.mulDiv(_ibtRate - _oldIBTRate, _ibtRate);
+        unchecked {
+               uint256 ibtRateMinusOldIbtRate = _ibtRate - _oldIBTRate;
+        }
+        newYieldInIBTRay = ibtOfPTInRay.mulDiv(ibtRateMinusOldIbtRate, _ibtRate);
    3.Use assembly to check for zero,address(0),msg.sender
You should first determine if zero check, address(0) check  is present in your code, and if so try to change these statements to inline assembly.
    4.Unnecessary casting or expression
Optimize Solidity code by avoiding unnecessary variable assignments, re-casting, or redundant expressions.In a function that returns multiple values, if only one value is required, avoid reassigning or re-casting both values unnecessarily.Also, there may be something about test.
    example:
    function getUints() public pure returns (uint, uint) {return (1, 2);}
    function funcA() public view {
        uint a; uint b; 
        (a, b) = getUints();
        uint g = gasleft();
-        (a, b) = getUints();
+        (a, ) = getUints();
        console.log(g - gasleft());
    }
    
solidity version :0.8.20
function state variables read:ibtRate, ptRate, ratesAtExpiryStored
function state variables written:
    function _getPTandIBTRates(bool roundUpPTRate) internal view returns (uint256, uint256) {
        if (ratesAtExpiryStored) {
            return (ptRate, ibtRate);
        } else {
            return _getCurrentPTandIBTRates(roundUpPTRate);
        }
    }

/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken-_getPTandIBTRates.txt
slitherConstructorConstantVariables:
there may be a problem : State variables only set in the constructor should be declared immutable in PrincipalToken
there may be a problem : Pack the variables into fewer storage slots by re-ordering the variables or reducing their sizes in PrincipalToken
there may be a problem : Using bools for storage incurs overhead in PrincipalToken
['3.3', '3.7', '2.5', '3.4']
hint message:
1.State variables only set in the constructor should be declared immutable & Use immutables variables directly instead of caching them in stack.
You should first find the variables set only in constructor and then set them immutable.
    2.Using bools for storage incurs overhead,instead use uint256
You first need to find those state variables that refer to bool. To mitigate these gas costs, you can utilize uint256 values uint256(1) and uint256(2) to represent true and false respectively including the variables in mapping.
    3.Using private rather than public for constants saves gas
You first need to find the variables with public and constant modifier, then convert it to private and rememeber to set the relevant read function to let the external contract read it.
-    uint256 public constant GAS_CONSTANT_A = 123;
-    uint256 public constant GAS_CONSTANT_B = 456;
+    uint256 private constant GAS_CONSTANT_A = 123;
+    uint256 private constant GAS_CONSTANT_B = 456;

+    function getAllPublicConstants() external pure returns (uint256, uint256) {
+        return (GAS_CONSTANT_A, GAS_CONSTANT_B);
+    }
    4.Pack the variables into fewer storage slots by re-ordering the variables or reducing their sizes
You should first determine whether there is a situation in which these variables can reduce size, such as some variables about time, and then after reducing size of the variable, you need to determine whether you can adjust the order of the variables to make storage more space-saving. And of course you also have to think about what's going on inside the struct.
    exmaple:
-    uint256 public LastDistribution;
    uint256 public MinDistributionPeriod;
+    uint48 public LastDistribution;
    bool public LockedForDistribution;
    LastDistribution can be reduced to uint48 since it holds block number so uint48 is more than sufficient to hold any realistic block number of any blockchain.
    
content:
solidity version :0.8.20
variable written only construct:['registry']
contract PrincipalToken is
    ERC20PermitUpgradeable,
    AccessManagedUpgradeable,
    ReentrancyGuardUpgradeable,
    PausableUpgradeable,
    IPrincipalToken
{
    using SafeERC20 for IERC20;
    using RayMath for uint256;
    using Math for uint256;
    uint256 private constant MIN_DECIMALS = 6;
    uint256 private constant MAX_DECIMALS = 18;
    bytes32 private constant ON_FLASH_LOAN = keccak256("ERC3156FlashBorrower.onFlashLoan");
    address private immutable registry;
    address private rewardsProxy;
    bool private ratesAtExpiryStored;
    address private ibt; // address of the Interest Bearing Token 4626 held by this PT vault
    address private _asset; // the asset of this PT vault (which is also the asset of the IBT 4626)
    address private yt; // YT corresponding to this PT, deployed at initialization
    uint256 private ibtUnit; // equal to one unit of the IBT held by this PT vault (10^decimals)
    uint256 private _ibtDecimals;
    uint256 private _assetDecimals;
    uint256 private ptRate; // or PT price in asset (in Ray)
    uint256 private ibtRate; // or IBT price in asset (in Ray)
    uint256 private unclaimedFeesInIBT; // unclaimed fees
    uint256 private totalFeesInIBT; // total fees
    uint256 private expiry; // date of maturity (set at initialization)
    uint256 private duration; // duration to maturity
    mapping(address => uint256) private ibtRateOfUser; // stores each user's IBT rate (in Ray)
    mapping(address => uint256) private ptRateOfUser; // stores each user's PT rate (in Ray)
    mapping(address => uint256) private yieldOfUserInIBT; // stores each user's yield generated from YTs
        address indexed user,
        uint256 indexed redeemedIbts,
        uint256 indexed receivedAssets
    );
    modifier notExpired() virtual {
        if (block.timestamp >= expiry) {
            revert PTExpired();
        }
        _;
    }
    modifier afterExpiry() virtual {
        if (block.timestamp < expiry) {
            revert PTNotExpired();
        }
        _;
    }
    constructor(address _registry) {
        if (_registry == address(0)) {
            revert AddressError();
        }
        registry = _registry;
        _disableInitializers(); // using this so that the deployed logic contract cannot later be initialized
    }

path:
/nasdata/ruanyijie/gas_optimization/src/result/spectra/PrincipalToken.txt
Traceback (most recent call last):
  File "/nasdata/ruanyijie/gas_optimization/src/test.py", line 182, in <module>
    slither = Slither(directory)
              ^^^^^^^^^^^^^^^^^^
  File "/home/ruanyijie/miniconda3/lib/python3.12/site-packages/slither/slither.py", line 135, in __init__
    crytic_compile = CryticCompile(target, **kwargs)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/ruanyijie/miniconda3/lib/python3.12/site-packages/crytic_compile/crytic_compile.py", line 211, in __init__
    self._compile(**kwargs)
  File "/home/ruanyijie/miniconda3/lib/python3.12/site-packages/crytic_compile/crytic_compile.py", line 633, in _compile
    self._platform.compile(self, **kwargs)
  File "/home/ruanyijie/miniconda3/lib/python3.12/site-packages/crytic_compile/platform/foundry.py", line 75, in compile
    run(
  File "/home/ruanyijie/miniconda3/lib/python3.12/site-packages/crytic_compile/utils/subprocess.py", line 48, in run
    return subprocess.run(
           ^^^^^^^^^^^^^^^
  File "/home/ruanyijie/miniconda3/lib/python3.12/subprocess.py", line 550, in run
    stdout, stderr = process.communicate(input, timeout=timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/ruanyijie/miniconda3/lib/python3.12/subprocess.py", line 1209, in communicate
    stdout, stderr = self._communicate(input, endtime, timeout)
                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/ruanyijie/miniconda3/lib/python3.12/subprocess.py", line 2108, in _communicate
    ready = selector.select(timeout)
            ^^^^^^^^^^^^^^^^^^^^^^^^
  File "/home/ruanyijie/miniconda3/lib/python3.12/selectors.py", line 415, in select
    fd_event_list = self._selector.poll(timeout)
                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^
KeyboardInterrupt
